<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-lu0k.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-lu0k.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-lu0k.png">
  <link rel="mask-icon" href="/images/lu0k.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lu0k.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="内容简介计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。GCC C语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。">
<meta property="og:type" content="article">
<meta property="og:title" content="程序的机器级表示(三)">
<meta property="og:url" content="https://lu0k.github.io/posts/mlr-program3/index.html">
<meta property="og:site_name" content="Lu0k">
<meta property="og:description" content="内容简介计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。GCC C语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lu0k.github.io/3-25.png">
<meta property="og:image" content="https://lu0k.github.io/3-26.png">
<meta property="og:image" content="https://lu0k.github.io/3-27.png">
<meta property="og:image" content="https://lu0k.github.io/3-28.png">
<meta property="og:image" content="https://lu0k.github.io/3-29.png">
<meta property="og:image" content="https://lu0k.github.io/3-30.png">
<meta property="og:image" content="https://lu0k.github.io/3-31.png">
<meta property="og:image" content="https://lu0k.github.io/3-32.png">
<meta property="og:image" content="https://lu0k.github.io/3-33.png">
<meta property="og:image" content="https://lu0k.github.io/3-34.png">
<meta property="og:image" content="https://lu0k.github.io/3-35.png">
<meta property="og:image" content="https://lu0k.github.io/3-36.png">
<meta property="og:image" content="https://lu0k.github.io/3-37.png">
<meta property="og:image" content="https://lu0k.github.io/3-38.png">
<meta property="article:published_time" content="2021-12-25T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-08T10:17:19.137Z">
<meta property="article:author" content="Lu0k">
<meta property="article:tag" content="CSAPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lu0k.github.io/3-25.png">


<link rel="canonical" href="https://lu0k.github.io/posts/mlr-program3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lu0k.github.io/posts/mlr-program3/","path":"posts/mlr-program3/","title":"程序的机器级表示(三)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>程序的机器级表示(三) | Lu0k</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Lu0k</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Lu0k's Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">内容简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88"><span class="nav-number">2.1.</span> <span class="nav-text">运行时栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6"><span class="nav-number">2.2.</span> <span class="nav-text">转移控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="nav-number">2.3.</span> <span class="nav-text">数据传送</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E4%B8%8A%E7%9A%84%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="nav-number">2.4.</span> <span class="nav-text">栈上的局部存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="nav-number">2.5.</span> <span class="nav-text">寄存器中的局部存储空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B"><span class="nav-number">2.6.</span> <span class="nav-text">递归过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%88%86%E9%85%8D%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="nav-number">3.</span> <span class="nav-text">数组分配和访问</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">3.1.</span> <span class="nav-text">基本原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="nav-number">3.2.</span> <span class="nav-text">指针运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">3.3.</span> <span class="nav-text">嵌套的数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84"><span class="nav-number">3.4.</span> <span class="nav-text">定长数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="nav-number">3.5.</span> <span class="nav-text">变长数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">4.</span> <span class="nav-text">Reference</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lu0k"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Lu0k</p>
  <div class="site-description" itemprop="description">谦虚学习!</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lu0k" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lu0k" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Lu0kMe" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Lu0kMe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lu0k.github.io/posts/mlr-program3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Lu0k">
      <meta itemprop="description" content="谦虚学习!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lu0k">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          程序的机器级表示(三)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 00:00:00" itemprop="dateCreated datePublished" datetime="2021-12-26T00:00:00+08:00">2021-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Read-Notes/" itemprop="url" rel="index"><span itemprop="name">Read Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><p>计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。GCC C语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。</p>
<span id="more"></span>

<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。不同编程语言中，过程的形式多样：函数<code>(function)</code>、方法<code>(method)</code>、子例程<code>(subroutine)</code>、处理函数<code>(handler)</code>等等，但是它们有一些共有的特性。</p>
<p>要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程<code>P</code>调用过程<code>Q</code>，<code>Q</code>执行后返回到<code>P</code>。这些动作包括下面一个或多个机制：</p>
<ul>
<li>传递控制：在进入过程<code>Q</code>的时候，程序计数器必须被设置为<code>Q</code>的代码的起始地址，然后在返回时，要把程序计数器设置为<code>P</code>中调用<code>Q</code>后面那条指令的地址</li>
<li>传递数据：<code>P</code>必须能够向<code>Q</code>提供一个或多个参数，<code>Q</code>必须能够向<code>P</code>返回一个值</li>
<li>分配和释放内存：在开始时，<code>Q</code>可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间</li>
</ul>
<p><code>x86-64</code>的过程实现包括一组特殊的指令和一些对机器资源<code>(例如寄存器和程序内存)</code>使用的约定规则。人们花了大量的力气来尽量减少过程调用的开销。所以，它遵循了被认为是最低要求策略的方法，只实现上述机制中每个过程所必需的那些。接下来，我们一步步地构建起不同的机制，先描述控制，再描述数据传递，最后是内存管理。</p>
<h2 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h2><p>C语言过程调用机制的一个关键特性<code>(大多数其他语言也是如此)</code>在于使用了栈数据结构提供的后进先出的内存管理原则。在过程<code>P</code>调用过程<code>Q</code>的例子中，可以看到当<code>Q</code>在执行时，<code>P</code>以及所有在向上追溯到<code>P</code>的调用链中的过程，都是暂时被挂起的。当<code>Q</code>运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。另一方面，当<code>Q</code>返回时，任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。当<code>P</code>调用<code>Q</code>时，控制和数据信息添加到栈尾。当<code>P</code>返回时，这些信息会释放掉。</p>
<p>如<code>3.4.4</code>节中讲过的，<code>x86-64</code>的栈向低地址方向增长，而栈指针<code>%rsp</code>指向栈顶元素。可以用<code>pushq</code>和<code>popq</code>指令将数据存入栈中或是从栈中取出。将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。类似地，可以通过增加栈指针来释放空间。</p>
<p>当<code>x86-64</code>过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧<code>(stack frame)</code>。图<code>3-25</code>给出了运行时栈的通用结构，包括把它划分为栈帧。当前正在执行的过程的帧总是在栈<br>顶。当过程<code>P</code>调用过程<code>Q</code>时，会把返回地址压入栈中，指明当<code>Q</code>返回时，要从<code>P</code>程序的哪个位置继续执行。我们把这个返回地址当做<code>P</code>的栈帧的一部分，因为它存放的是与<code>P</code>相关的状态。<code>Q</code>的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。大多数过程的栈帧都是定长的，在过程的开始就分配好了。但是有些过程需要变长的帧，这个问题会在<code>3.10.5</code>节中讨论。通过寄存器，过程<code>P</code>可以传递最多6个整数值<code>(也就是指针和整数)</code>，但是如果<code>Q</code>需要更多的参数，<code>P</code>可以在调用<code>Q</code>之前在自己的栈帧里存储好这些参数。</p>
<p><img src="/3-25.png"></p>
<p>为了提高空间和时间效率，<code>x86-64</code>过程只分配自己所需要的栈帧部分。例如，许多过程有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。因此，图<code>3-25</code>中画出的某些栈帧部分可以省略。实际上，许多函数甚至根本不需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数<code>(有时称之为叶子过程，此时把过程调用看做树结构)</code>时，就可以这样处理。例如，到目前为止我们仔细审视过的所有函数都不需要栈帧。</p>
<h2 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h2><p>将控制从函数<code>P</code>转移到函数<code>Q</code>只需要简单地把程序计数器<code>(PC)</code>设置为<code>Q</code>的代码的起始位置。不过，当稍后从<code>Q</code>返回的时候，处理器必须记录好它需要继续<code>P</code>的执行的代码位置。在<code>x86-64</code>机器中，这个信息是用指令<code>call Q</code>调用过程<code>Q</code>来记录的。该指令会把地址<code>A</code>压入栈中，并将<code>PC</code>设置为<code>Q</code>的起始地址。压入的地址<code>A</code>被称为返回地址，是紧跟在<code>call</code>指令后面的那条指令的地址。对应的指令<code>ret</code>会从栈中弹出地址<code>A</code>，并把<code>PC</code>设置为<code>A</code>。下表给出的是<code>call</code>和<code>ret</code>指令的一般形式：</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">call Label<br />call *Operand<br />ret</td>
<td align="center">过程调用<br />过程调用<br />从过程调用中返回</td>
</tr>
</tbody></table>
<p><code>(这些指令在程序OBJDUMP产生的反汇编输出中被称为callq和retq。添加的后缀q只是为了强调这些是x86-64版本的调用和返回，而不是IA32的。在x86-64汇编代码中，这两种版本可以互换。)</code></p>
<p><code>call</code>指令有一个目标，即指明被调用过程起始的指令地址。同跳转一样，调用可以是直接的，也可以是间接的。在汇编代码中，直接调用的目标是一个标号，而间接调用的目标是<code>*</code>后面跟一个操作数指示符，使用的是图<code>3-3</code>中描述的格式之一。</p>
<p><img src="/3-26.png"></p>
<p>图<code>3-26</code>说明了<code>3.2.2</code>节中介绍的<code>multstore</code>和<code>main</code>函数的<code>call</code>和<code>ret</code>指令的执行情况。下面是这两个函数的反汇编代码的节选：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; Beginning of function multstore</span><br><span class="line">0000000000400540 &lt;multstore&gt;:</span><br><span class="line">    400540: 53                   push %rbx</span><br><span class="line">    400541: 48 89 d3             mov %rdx,%rbx</span><br><span class="line">    ...</span><br><span class="line">; Return from function multstore</span><br><span class="line">    40054d: c3                   retq</span><br><span class="line">    ...</span><br><span class="line">; Call to multstore from main</span><br><span class="line">    400563: e8 d8 ff ff ff       callq 400540 &lt;multstore&gt;</span><br><span class="line">    400568: 48 8b 54 24 08       mov 0x8(%rsp),%rdx</span><br></pre></td></tr></table></figure>

<p>在这段代码中我们可以看到，在<code>main</code>函数中，地址为<code>0x400563</code>的<code>call</code>指令调用函数<code>multstore</code>。此时的状态如图<code>3-26a</code>所示，指明了栈指针<code>%rsp</code>和程序计数器<code>%rip</code>的值。<code>call</code>的效果是将返回地址<code>0x400568</code>压入栈中，并跳到函数<code>multstore</code>的第一条指令，地址为<code>0x0400540(图3-26b)</code>。函数<code>multstore</code>继续执行，直到遇到地址<code>0x40054d</code>处的<code>ret</code>指令。这条指令从栈中弹出值<code>0x400568</code>，然后跳转到这个地址，就在<code>call</code>指令之后，继续<code>main</code>函数的执行。</p>
<p><img src="/3-27.png"></p>
<p>再来看一个更详细说明在过程间传递控制的例子，图<code>3-27a</code>给出了两个函数<code>top</code>和<code>leaf</code>的反汇编代码，以及<code>main</code>函数中调用<code>top</code>处的代码。每条指令都以标号标出：<code>L1~L2(leaf中)</code>，<code>T1~T4(top中)</code>和<code>M1~M2(main中)</code>。该图的<code>b</code>部分给出了这段代码执行的详细过程，<code>main</code>调用<code>top(100)</code>，然后<code>top</code>调用<code>leaf(95)</code>。函数<code>leaf</code>向 <code>top</code>返回97，然后<code>top</code>向<code>main</code>返回194。前面三列描述了被执行的指令，包括指令标号、地址和指令类型。后面四列给出了在该指令执行前程序的状态，包括寄存器<code>%rdi</code>、<code>%rax</code>和<code>%rsp</code>的内容，以及位于栈顶的值。仔细研究这张表的内容，它们说明了运行时栈在管理支持过程调用和返回所需的存储空间中的重要作用。</p>
<p><code>leaf</code>的指令<code>L1</code>将<code>%rax</code>设置为97，也就是要返回的值。然后指令<code>L2</code>返回，它从栈中弹出<code>0x400054e</code>。通过将<code>PC</code>设置为这个弹出的值，控制转移回<code>top</code>的<code>T3</code>指令。程序成功完成对<code>leaf</code>的调用，返回到<code>top</code>。</p>
<p>指令<code>T3</code>将<code>%rax</code>设置为194，也就是要从<code>top</code>返回的值。然后指令<code>T4</code>返回，它从栈中弹出<code>0x4000560</code>，因此将<code>PC</code>设置为<code>main</code>的<code>M2</code>指令。程序成功完成对<code>top</code>的调用，返回到<code>main</code>。可以看到，此时栈指针也恢复成了<code>0x7fffffffe820</code>，即调用<code>top</code>之前的值。</p>
<p>可以看到，这种把返回地址压入栈的简单的机制能够让函数在稍后返回到程序中正确的点。C语言<code>(以及大多数程序语言)</code>标准的调用&#x2F;返回机制刚好与栈提供的后进先出的内存管理方法吻合。</p>
<h2 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h2><p>当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。<code>x86-64</code>中，大部分过程间的数据传送是通过寄存器实现的。例如，我们已经看到无数的函数示例，参数在寄存器<code>%rdi</code>、<code>%rsi</code>和其他寄存器中传递。当过程<code>P</code>调用过程<code>Q</code>时，<code>P</code>的代码必须首先把参数复制到适当的寄存器中。类似地，当<code>Q</code>返回到<code>P</code>时，<code>P</code>的代码可以访问寄存器<code>%rax</code>中的返回值。</p>
<p><code>x86-64</code>中，可以通过寄存器最多传递6个整型<code>(即整数和指针)</code>参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，如图<code>3-28</code>所示。会根据参数在参数列表中的顺序为它们分配寄存器。可以通过64位寄存器适当的部分访问小于64位的参数。例如，如果第一个参数是32位的，那么可以用<code>%edi</code>来访问它。</p>
<p><img src="/3-28.png"></p>
<p>如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递。假设过程<code>P</code>调用过程<code>Q</code>，有<code>n</code>个整型参数，且<code>n&gt;6</code>。那么<code>P</code>的代码分配的栈帧必须要能容纳7到<code>n</code>号参数的存储空间，如图<code>3-25</code>所示。要把参数<code>1~6</code>复制到对应的寄存器，把参数<code>7~n</code>放到栈上，而参数7位于栈顶。通过栈传递参数时，所有的数据大小都向8的倍数对齐。参数到位以后，程序就可以执行<code>call</code>指令将控制转移到过程<code>Q</code>了。过程<code>Q</code>可以通过寄存器访问参数，有必要的话也可以通过栈访问。相应地，如果<code>Q</code>也调用了某个有超过6个参数的函数，它也需要在自己的栈帧中为超出6个部分的参数分配空间，如图<code>3-25</code>中标号为<code>参数构造区</code>的区域所示。</p>
<p>作为参数传递的示例，考虑图<code>3-29a</code>所示的C函数<code>proc</code>。这个函数有8个参数，包括字节数不同的整数<code>(8、4、2和1)</code>和不同类型的指针，每个指针都是8字节的。</p>
<p><img src="/3-29.png"></p>
<p>图<code>3-29b</code>中给出<code>proc</code>生成的汇编代码。前面6个参数通过寄存器传递，后面2个通过栈传递，就像图<code>3-30</code>中画出来的那样。可以看到，作为过程调用的一部分，返回地址被压入栈中。因而这两个参数位于相对于栈指针距离为8和16的位置。在这段代码中，我们可以看到根据操作数的大小，使用了<code>ADD</code>指令的不同版本：<code>a1(long)</code>使用<code>addq</code>，<code>a2(int)</code>使用<code>addl</code>，<code>a3(short)</code>使用<code>addw</code>，而<code>a4(char)</code>使用<code>addb</code>。请注意第6行的<code>movl</code>指令从内存读入4字节，而后面的<code>addb</code>指令只使用其中的低位一字节。</p>
<p><img src="/3-30.png"></p>
<h2 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h2><p>到目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不过有些时候，局部数据必须存放在内存中，常见的情况包括：</p>
<ul>
<li>寄存器不足够存放所有的本地数据</li>
<li>对一个局部变量使用地址运算符<code>&amp;</code>，因此必须能够为它产生一个地址</li>
<li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。在描述数组和结构分配时，我们会讨论这个问题</li>
</ul>
<p>一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为<code>局部变量</code>，如图<code>3-25</code>所示。</p>
<p><img src="/3-31.png"></p>
<p>来看一个处理地址运算符的例子，图<code>3-31a</code>中给出的两个函数。函数<code>swap_add</code>交换指针<code>xp</code>和<code>yp</code>指向的两个值，并返回这两个值的和。函数<code>caller</code>创建到局部变量<code>arg1</code>和<code>arg2</code>的指针，把它们传递给<code>swap_add</code>。图<code>3-31b</code>展示了<code>caller</code>是如何用栈帧来实现这些局部变量的。<code>caller</code>的代码开始的时候把栈指针减掉了16；实际上这就是在栈上分配了16个字节。<code>S</code>表示栈指针的值，可以看到这段代码计算<code>&amp;arg2</code>为<code>S+8(第5行)</code>，而<code>&amp;arg1</code>为<code>S</code>。因此可以推断局部变量<code>arg1</code>和<code>arg2</code>存放在栈帧中相对于栈指针偏移量为0和8的地方。当对<code>swap_add</code>的调用完成后，<code>caller</code>的代码会从栈上取出这两个值<code>(第8~9行)</code>，计算它们的差，再乘以<code>swap_add</code>在寄存器<code>%rax</code>中返回的值<code>(第10行)</code>。最后，该函数把栈指针加16，释放栈帧<code>(第11行)</code>。通过这个例子可以看到，运行时栈提供了一种简单的、在需要时分配、函数完成时释放局部存储的机制。</p>
<p><img src="/3-32.png"></p>
<p>如图<code>3-32</code>所示，函数<code>call_proc</code>是一个更复杂的例子，说明<code>x86-64</code>栈行为的一些特性。尽管这个例子有点长，但还是值得仔细研究。它给出了一个必须在栈上分配局部变量存储空间的函数，同时还要向有8个参数的函数<code>proc</code>传递值<code>(图3-29)</code>。该函数创建一个栈帧，如图<code>3-33</code>所示。</p>
<p><img src="/3-33.png"></p>
<p>看<code>call_proc</code>的汇编代码<code>(图3-32b)</code>，可以看到代码中一大部分<code>(第2~15行)</code>是为调用<code>proc</code>做准备。其中包括为局部变量和函数参数建立栈帧，将函数参数加载至寄存器。如图<code>3-33</code>所示，在栈上分配局部变量<code>x1~x4</code>，它们具有不同的大小：<code>24~31(x1)</code>，<code>20~23(x2)</code>，<code>18~19(x3)</code>和<code>17(s3)</code>。用<code>leaq</code>指令生成到这些位置的指针<code>(第7、10、12和14行)</code>。参数7<code>(值为4)</code>和8<code>(指向x4的位置的指针)</code>存放在栈中相对于栈指针偏移量为0和8的地方。</p>
<p>当调用过程<code>proc</code>时，程序会开始执行图<code>3-29b</code>中的代码。如图<code>3-30</code>所示，参数7和8现在位于相对于栈指针偏移量为8和16的地方，因为返回地址这时已经被压入栈中了。当程序返回<code>call_proc</code>时，代码会取出4个局部变量<code>(第17~20行)</code>，并执行最终的计算。在程序结束前，把栈指针加32，释放这个栈帧。</p>
<h2 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h2><p>寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程<code>(调用者)</code>调用另一个过程<code>(被调用者)</code>时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，<code>x86-64</code>采用了一组统一的寄存器使用惯例，所有的过程<code>(包括程序库)</code>都必须遵循。</p>
<p>根据惯例，寄存器<code>%rbx</code>、<code>%rbp</code>和<code>%r12~%r15</code>被划分为被调用者保存寄存器。当过程<code>P</code>调用过程<code>Q</code>时，<code>Q</code>必须保存这些寄存器的值，保证它们的值在<code>Q</code>返回到<code>P</code>时与<code>Q</code>被调用时是一样的。过程<code>Q</code>保存一个寄存器的值不变，要么是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为<code>被保存的寄存器</code>的一部分，如图<code>3-25</code>中所示。有了这条惯例，<code>P</code>的代码就能安全地把值存在被调用者保存寄存器中<code>(当然，要先把之前的值保存到栈上)</code>，调用<code>Q</code>，然后继续使用寄存器中的值，不用担心值被破坏。</p>
<p>所有其他的寄存器，除了栈指针<code>%rsp</code>，都分类为调用者保存寄存器。这就意味着任何函数都能修改它们。可以这样来理解<code>调用者保存</code>这个名字：过程<code>P</code>在某个此类寄存器中有局部数据，然后调用过程<code>Q</code>。因为<code>Q</code>可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是<code>P(调用者)</code>的责任。</p>
<p>来看一个例子，图<code>3-34a</code>中的函数<code>P</code>。它两次调用<code>Q</code>。在第一次调用中，必须保存<code>x</code>的值以备后面使用。类似地，在第二次调用中，也必须保存<code>Q(y)</code>的值。图<code>3-34b</code>中，可以看到<code>GCC</code>生成的代码使用了两个被调用者保存寄存器：<code>%rbp</code>保存<code>x</code>和<code>%rbx</code>保存计算出来的<code>Q(y)</code>的值。在函数的开头，把这两个寄存器的值保存到栈中<code>(第2~3行)</code>。在第一次调用<code>Q</code>之前，把参数<code>x</code>复制到<code>%rbp(第5行)</code>。在第二次调用<code>Q</code>之前，把这次调用的结果复制到<code>%rbx(第8行)</code>。在函数的结尾<code>(第13~14行)</code>，把它们从栈中弹出，恢复这两个被调用者保存寄存器的值。注意它们的弹出顺序与压入顺序相反，说明了栈的后进先出规则。</p>
<p><img src="/3-34.png"></p>
<h2 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h2><p>前面已经描述的寄存器和栈的惯例使得<code>x86-64</code>过程能够递归地调用它们自身。每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。此外，栈的原则很自然地就提供了适当的策略，当过程被调用时分配局部存储，当返回时释放存储。</p>
<p>图<code>3-35</code>给出了递归的阶乘函数的C代码和生成的汇编代码。可以看到汇编代码使用寄存器<code>%rbx</code>来保存参数<code>n</code>，先把已有的值保存在栈上<code>(第2行)</code>，随后在返回前恢复该值<code>(第11行)</code>。根据栈的使用特性和寄存器保存规则，可以保证当递归调用<code>rfact(n-1)</code>返回时<code>(第9行)</code>：</p>
<ul>
<li>该次调用的结果会保存在寄存器<code>%rax</code>中</li>
<li>参数<code>n</code>的值仍然在寄存器<code>%rbx</code>中，把这两个值相乘就能得到期望的结果</li>
</ul>
<p>从这个例子我们可以看到，递归调用一个函数本身与调用其他函数是一样的。栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息<code>(保存的返回位置和被调用者保存寄存器的值)</code>存储空间。如果需要，它还可以提供局部变量的存储。栈分配和释放的规则很自然地就与函数调用、返回的顺序匹配。这种实现函数调用和返回的方法甚至对更复杂的情况也适用，包括相互递归调用<code>(例如，过程P调用Q，Q再调用P)</code>。</p>
<p><img src="/3-35.png"></p>
<h1 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h1><p>C语言中的数组是一种将标量数据聚集成更大数据类型的方式。C语言实现数组的方式非常简单，因此很容易翻译成机器代码。C语言的一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算。优化编译器非常善于简化数组索引所使用的地址计算。不过这使得C代码和它到机器代码的翻译之间的对应关系有些难以理解。</p>
<h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><p>对于数据类型<code>T</code>和整型常数<code>N</code>，声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T A[N];</span><br></pre></td></tr></table></figure>

<p>起始位置表示为x<sub>A</sub>。这个声明有两个效果。首先，它在内存中分配一个<code>L*N</code>字节的连续区域，这里<code>L</code>是数据类型<code>T</code>的大小<code>(单位为字节)</code>。其次，它引入了标识符<code>A</code>，可以用<code>A</code>来作为指向数组开头的指针，这个指针的值就是x<sub>A</sub>。可以用<code>0~N-1</code>的整数索引来访问该数组元素。数组元素<code>i</code>会被存放在地址为x<sub>A</sub>+<code>L·i</code>的地方。</p>
<p>作为示例，让我们来看看下面这样的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>    A[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">char</span>    *B[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span>     C[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">double</span>  *D[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>这些声明会产生带下列参数的数组：</p>
<table>
<thead>
<tr>
<th align="center">数组</th>
<th align="center">元素大小</th>
<th align="center">总的大小</th>
<th align="center">起始地址</th>
<th align="center">元素<code>i</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">1</td>
<td align="center">12</td>
<td align="center">x<sub>A</sub></td>
<td align="center">x<sub>A</sub><code>+i</code></td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">8</td>
<td align="center">64</td>
<td align="center">x<sub>B</sub></td>
<td align="center">x<sub>B</sub><code>+i</code></td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">4</td>
<td align="center">24</td>
<td align="center">x<sub>C</sub></td>
<td align="center">x<sub>C</sub><code>+i</code></td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">8</td>
<td align="center">40</td>
<td align="center">x<sub>D</sub></td>
<td align="center">x<sub>D</sub><code>+i</code></td>
</tr>
</tbody></table>
<p>数组<code>A</code>由12个单字节<code>(char)</code>元素组成。数组<code>C</code>由6个整数组成，每个需要4个字节。<code>B</code>和<code>D</code>都是指针数组，因此每个数组元素都是8个字节。<code>x86-64</code>的内存引用指令可以用来简化数组访问。例如，假设<code>E</code>是一个<code>int</code>型的数组，而我们想计算<code>E[i]</code>，在此，<code>E</code>的地址存放在寄存器<code>%rdx</code>中，而<code>i</code>存放在寄存器<code>%rcx</code>中。然后，指令<code>movl (%rdx, %rcx, 4), %eax</code>会执行地址计算x<sub>E</sub><code>+4i</code>，读这个内存位置的值，并将结果存放到寄存器<code>%eax</code>中。允许的伸缩因子1、2、4和8覆盖了所有基本简单数据类型的大小。</p>
<h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><p>C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果<code>p</code>是一个指向类型为<code>T</code>的数据的指针，<code>p</code>的值为x<sub>p</sub>，那么表达式<code>p+i</code>的值为x<sub>p</sub><code>+L·i</code>，这里<code>L</code>是数据类型<code>T</code>的大小。</p>
<p>单操作数操作符<code>&amp;</code>和<code>*</code>可以产生指针和间接引用指针。也就是，对于一个表示某个对象的表达式<code>Expr</code>，<code>&amp;Expr</code>是给出该对象地址的一个指针。对于一个表示地址的表达式<code>AExpr</code>，<code>*AExpr</code>给出该地址处的值。因此，表达式<code>Expr</code>与<code>*&amp;Expr</code>是等价的。可以对数组和指针应用数组下标操作。数组引用<code>A[i]</code>等同于表达式<code>*(A+i)</code>。它计算第<code>i</code>个数组元素的地址，然后访问这个内存位置。</p>
<p>扩展一下前面的例子，假设整型数组<code>E</code>的起始地址和整数索引<code>i</code>分别存放在寄存器<code>%rdx</code>和<code>%rcx</code>中。下面是一些与<code>E</code>有关的表达式。我们还给出了每个表达式的汇编代码实现，结果存放在寄存器<code>%eax(如果是数据)</code>或寄存器<code>%rax(如果是指针)</code>中。</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">类型</th>
<th align="center">值</th>
<th align="center">汇编代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>E</code></td>
<td align="center">int *</td>
<td align="center">x<sub>E</sub></td>
<td align="center"><code>movq %rdx, %rax</code></td>
</tr>
<tr>
<td align="center"><code>E[0]</code></td>
<td align="center">int</td>
<td align="center">M[x<sub>E</sub>]</td>
<td align="center"><code>movl (%rdx), %eax</code></td>
</tr>
<tr>
<td align="center"><code>E[i]</code></td>
<td align="center">int</td>
<td align="center">M[x<sub>E</sub>+4i]</td>
<td align="center"><code>movl (%rdx, %rcx, 4), %eax</code></td>
</tr>
<tr>
<td align="center"><code>&amp;E[2]</code></td>
<td align="center">int *</td>
<td align="center">x<sub>E</sub>+8</td>
<td align="center"><code>leaq 8(%rdx), %rax</code></td>
</tr>
<tr>
<td align="center"><code>E+i-1</code></td>
<td align="center">int *</td>
<td align="center">x<sub>E</sub>+4i-4</td>
<td align="center"><code>leaq -4(%rdx, %rcx, 4), %rax</code></td>
</tr>
<tr>
<td align="center"><code>*(E+i-3)</code></td>
<td align="center">int</td>
<td align="center">M[x<sub>E</sub>+4i-12]</td>
<td align="center"><code>movl -4(%rdx, %rcx, 4), %eax</code></td>
</tr>
<tr>
<td align="center"><code>E[i]-E</code></td>
<td align="center">long</td>
<td align="center"><code>i</code></td>
<td align="center"><code>movq %rcx, %rax</code></td>
</tr>
</tbody></table>
<p>在这些例子中，可以看到返回数组值的操作类型为<code>int</code>，因此涉及4字节操作<code>(例如movl)</code>和寄存器<code>(例如%eax)</code>。那些返回指针的操作类型为<code>int*</code>，因此涉及8字节操作<code>(例如leaq)</code>和寄存器<code>(例如%rax)</code>。最后一个例子表明可以计算同一个数据结构中的两个指针之差，结果的数据类型为<code>long</code>，值等于两个地址之差除以该数据类型的大小。</p>
<h2 id="嵌套的数组"><a href="#嵌套的数组" class="headerlink" title="嵌套的数组"></a>嵌套的数组</h2><p>当我们创建数组的数组时，数组分配和引用的一般原则也是成立的。例如，声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[<span class="number">5</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>等价于下面的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">row3_t</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">row3_t</span> A[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>数据类型<code>row3_t</code>被定义为一个3个整数的数组。数组<code>A</code>包含5个这样的元素，每个元素需要12个字节来存储3个整数。整个数组的大小就是<code>4x5x3=60</code>字节。</p>
<p>数组<code>A</code>还可以被看成一个5行3列的二维数组，用<code>A[0][0]</code>到<code>A[4][2]</code>来引用。数组元素在内存中按照<code>行优先</code>的顺序排列，意味着第0行的所有元素，可以写作<code>A[0]</code>，后面跟着第1行的所有元素<code>(A[1])</code>，以此类推，如图<code>3-36</code>所示。</p>
<p><img src="/3-36.png"></p>
<p>这种排列顺序是嵌套声明的结果。将<code>A</code>看作一个有5个元素的数组，每个元素都是3个<code>int</code>的数组，首先是<code>A[0]</code>，然后是<code>A[1]</code>，以此类推。要访问多维数组的元素，编译器会以数组起始为基地址，<code>(可能需要经过伸缩的)</code>偏移量为索引，产生计算期望的元素的偏移量，然后使用某种<code>MOV</code>指令。通常来说，对于一个声明如下的数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T D[R][C];</span><br></pre></td></tr></table></figure>

<p>它的数组元素<code>D[i][j]</code>的内存地址为<code>&amp;D[i][j]=</code>x<sub>0</sub><code>+L(C·i+j)</code>——公式<code>(3.1)</code>。</p>
<p>这里，<code>L</code>是数据类型<code>T</code>以字节为单位的大小。作为一个示例，考虑前面定义的<code>5x3</code>的整型数组<code>A</code>。假设x<sub>A</sub>、<code>i</code>和<code>j</code>分别在寄存器<code>%rdi</code>、<code>%rsi</code>和<code>%rdx</code>中。然后，可以用下面的代码将数组元素<code>A[i][j]</code>复制到寄存器<code>%eax</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; A in %rdi, i in %rsi, and j in %rdx</span><br><span class="line">leaq (%rsi,%rsi,2), %rax    ; Compute 3i</span><br><span class="line">leaq (%rdi,%rax,4), %rax    ; Compute xA + 12i</span><br><span class="line">movl (%rax,%rdx,4), %eax    ; Read from M[xA + 12i + 4j]</span><br></pre></td></tr></table></figure>

<p>正如可以看到的那样，这段代码计算元素的地址为x<sub>A</sub><code>+12i+4j=</code>x<sub>A</sub><code>+4(3i+j)</code>，使用<code>x86-64</code>地址运算的伸缩和加法特性。</p>
<h2 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h2><p>C语言编译器能够优化定长多维数组上的操作代码。这里我们展示优化等级设置为<code>-O1</code>时<code>GCC</code>采用的一些优化。假设我们用如下方式将数据类型<code>fix_matrix</code>声明为<code>16x16</code>的整型数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 16</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> fix_matrix[N][N];</span><br></pre></td></tr></table></figure>

<p><code>(这个例子说明了一个很好的编码习惯。当程序要用一个常数作为数组的维度或者缓冲区的大小时，最好通过# define声明将这个常数与一个名字联系起来，然后在后面一直使用这个名字代替常数的数值。这样一来，如果需要修改这个值，只用简单地修改这个# define声明就可以了。)</code>图<code>3-37a</code>中的代码计算矩阵<code>A</code>和<code>B</code>乘积的元素<code>i</code>，<code>k</code>，即<code>A</code>的行<code>i</code>和<code>B</code>的列<code>k</code>的内积。<code>GCC</code>产生的代码<code>(我们再反汇编成C)</code>，如图<code>3-37b</code>中函数<code>fix_prod_ele_opt</code>所示。这段代码包含很多聪明的优化。它去掉了整数索引<code>j</code>，并把所有的数组引用都转换成了指针间接引用，其中包括：</p>
<ul>
<li>生成一个指针，命名为<code>Aptr</code>，指向<code>A</code>的行<code>i</code>中连续的元素</li>
<li>生成一个指针，命名为<code>Bptr</code>，指向<code>B</code>的列<code>k</code>中连续的元素</li>
<li>生成一个指针，命名为<code>Bend</code>，当需要终止该循环时，它会等于<code>Bptr</code>的值。</li>
</ul>
<p><code>Aptr</code>的初始值是<code>A</code>的行<code>i</code>的第一个元素的地址，由C表达式<code>&amp;A[i][0]</code>给出。<code>Bptr</code>的初始值是<code>B</code>的列<code>k</code>的第一个元素的地址，由C表达式<code>&amp;B[0][k]</code>给出。<code>Bend</code>的值是假想中<code>B</code>的列<code>j</code>的第<code>(n+1)</code>个元素的地址，由C表达式<code>&amp;B[N][k]</code>给出。</p>
<p><img src="/3-37.png"></p>
<p>下面给出的是<code>GCC</code>为函数<code>fix_prod_ele</code>生成的这个循环的实际汇编代码。我们看到4个寄存器的使用如下：<code>%eax</code>保存<code>result</code>，<code>%rdi</code>保存<code>Aptr</code>，<code>%rcx</code>保存<code>Bptr</code>，而<code>%rsi</code>保存<code>Bend</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; int fix_prod_ele_opt(fix_matrix A, fix_matrix B, long i, long k)</span><br><span class="line">; A in %rdi, B in %rsi, i in %rdx, k in %rcx</span><br><span class="line">fix_prod_ele:</span><br><span class="line">    salq $6, %rdx            ;   Compute 64 * i</span><br><span class="line">    addq %rdx, %rdi          ;   Compute Aptr = xA + 64i = &amp;A[i][0]</span><br><span class="line">    leaq (%rsi,%rcx,4), %rcx ;   Compute Bptr = xB + 4k = &amp;B[0][k]</span><br><span class="line">    leaq 1024(%rcx), %rsi    ;   Compute Bend = xB + 4k + 1024 = &amp;B[N][k]</span><br><span class="line">    movl $0, %eax            ;   Set result = 0</span><br><span class="line">.L7:                         ; loop:</span><br><span class="line">    movl (%rdi), %edx        ;   Read *Aptr</span><br><span class="line">    imull (%rcx), %edx       ;   Multiply by *Bptr</span><br><span class="line">    addl %edx, %eax          ;   Add to result</span><br><span class="line">    addq $4, %rdi            ;   Increment Aptr ++</span><br><span class="line">    addq $64, %rcx           ;   Increment Bptr += N</span><br><span class="line">    cmpq %rsi, %rcx          ;   Compare Bptr:Bend</span><br><span class="line">    jne .L7                  ;   If !=, goto loop</span><br><span class="line">    rep; ret                 ;   Return</span><br></pre></td></tr></table></figure>

<h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>历史上，C语言只支持大小在编译时就能确定的多维数组<code>(对第一维可能有些例外)</code>。程序员需要变长数组时不得不用<code>malloc</code>或<code>calloc</code>这样的函数为这些数组分配存储空间，而且不得不显式地编码，用行优先索引将多维数组映射到一维数组，如公式<code>(3.1)</code>所示。<code>ISOC99</code>引入了一种功能，允许数组的维度是表达式，在数组被分配的时候才计算出来。</p>
<p>在变长数组的C版本中，我们可以将一个数组声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[exprl] [expr2];</span><br></pre></td></tr></table></figure>

<p>它可以作为一个局部变量，也可以作为一个函数的参数，然后在遇到这个声明的时候，通过对表达式<code>expr1</code>和<code>expr2</code>求值来确定数组的维度。因此，例如要访问<code>NxN</code>数组的元素<code>i</code>，<code>j</code>，我们可以写一个如下的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">var_ele</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">int</span> A[n][n],<span class="keyword">long</span> i,<span class="number">1</span>ong j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>n</code>必须在参数<code>A[n][n]</code>之前，这样函数就可以在遇到这个数组的时候计算出数组的维度。<code>GCC</code>为这个引用函数产生的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; int var_ele(long n, int A[n][n], long i, long j)</span><br><span class="line">; n in %rdi, A in %rsi, i in %rdx, j in %rcx</span><br><span class="line">var_ele:</span><br><span class="line">    imulq %rdx, %rdi          ; Compute n·i</span><br><span class="line">    leaq (%rsi,%rdi,4), %rax  ; Compute xA + 4(n·i)</span><br><span class="line">    movl (%rax,%rcx,4), %eax  ; Read from M[xA + 4(n·i) + 4j ]</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>正如注释所示，这段代码计算元素<code>i</code>，<code>j</code>的地址为x<sub>A</sub><code>+4(n·i)+4j=</code>x<sub>A</sub><code>+4(n·i+j)</code>。这个地址的计算类似于定长数组的地址计算<code>(参见3.8.3节)</code>，不同点在于：</p>
<ul>
<li>由于增加了参数<code>n</code>，寄存器的使用变化了</li>
<li>用了乘法指令来计算<code>n·i(第2行)</code>，而不是用<code>leaq</code>指令来计算<code>3i</code></li>
</ul>
<p>因此引用变长数组只需要对定长数组做一点概括。动态的版本必须用乘法指令对<code>i</code>伸缩<code>n</code>倍，而不能用一系列的移位和加法。在一些处理器中，乘法会招致严重的性能处罚，但是在这种情况中无可避免。</p>
<p><img src="/3-38.png"></p>
<p>在一个循环中引用变长数组时，编译器常常可以利用访问模式的规律性来优化索引的计算。例如，图<code>3-38a</code>给出的C代码，它计算两个<code>NxN</code>矩阵<code>A</code>和<code>B</code>乘积的元素<code>i</code>，<code>k</code>。<code>GCC</code>产生的汇编代码，我们再重新变为C代码<code>(图3-38b)</code>。这个代码与固定大小数组的优化代码<code>(图3-37)</code>风格不同，不过这更多的是编译器选择的结果，而不是两个函数有什么根本的不同造成的。图<code>3-38b</code>的代码保留了循环变量<code>j</code>，用以判定循环是否结束和作为到<code>A</code>的行<code>i</code>的元素组成的数组的索引。下面是<code>var_prod_ele</code>的循环的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; Registers: n in %rdi, Arow in %rsi, Bptr in %rcx</span><br><span class="line">;            4n in %r9, result in %eax, j in %edx</span><br><span class="line">.L24:                         ; loop:</span><br><span class="line">    movl (%rsi,%rdx,4), %r8d  ;   Read Arow[j]</span><br><span class="line">    imull (%rcx), %r8d        ;   Multiply by *Bptr</span><br><span class="line">    addl %r8d, %eax           ;   Add to result</span><br><span class="line">    addq $1, %rdx             ;   j++</span><br><span class="line">    addq %r9, %rcx            ;   Bptr += n</span><br><span class="line">    cmpq %rdi, %rdx           ;   Compare j:n</span><br><span class="line">    jne .L24                  ;   If !=, goto loop</span><br></pre></td></tr></table></figure>

<p>我们看到程序既使用了伸缩过的值<code>4n(寄存器%r9)</code>来增加<code>Bptr</code>，也使用了<code>n</code>的值<code>(寄存器%rdi)</code>来检查循环的边界。C代码中并没有体现出需要这两个值，但是由于指针运算的伸缩，才使用了这两个值。</p>
<p>可以看到，如果允许使用优化，<code>GCC</code>能够识别出程序访问多维数组的元素的步长。然后生成的代码会避免直接应用等式<code>(3.1)</code>会导致的乘法。不论生成基于指针的代码<code>(图3-37b)</code>还是基于数组的代码<code>(图3-38b)</code>，这些优化都能显著提高程序的性能。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://csapp.cs.cmu.edu/"><code>Computer Systems: A Programmer&#39;s Perspective, 3/E</code></a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CSAPP/" rel="tag"><i class="fa fa-tag"></i> CSAPP</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/mlr-program2/" rel="prev" title="程序的机器级表示(二)">
                  <i class="fa fa-chevron-left"></i> 程序的机器级表示(二)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/htb-m0rsarchive/" rel="next" title="HTB M0rsarchive">
                  HTB M0rsarchive <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lu0k</span>
</div>

    </div>
  </footer>

  
  <script size="250" alpha="0.5" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  





</body>
</html>
