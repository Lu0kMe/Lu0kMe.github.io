<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-lu0k.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-lu0k.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-lu0k.png">
  <link rel="mask-icon" href="/images/lu0k.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lu0k.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="内容简介存储器系统(memory system)是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU寄存器保存着最常用的数据。靠近CPU的小的、快速的高速缓存存储器(cache memory)作为一部分存储在相对慢速的主存储器(main memory)中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为存储在通过网络连接的其他机器的磁盘或磁带上的数据的">
<meta property="og:type" content="article">
<meta property="og:title" content="存储器层次结构(一)">
<meta property="og:url" content="https://lu0k.github.io/posts/mem-hier1/index.html">
<meta property="og:site_name" content="Lu0k">
<meta property="og:description" content="内容简介存储器系统(memory system)是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU寄存器保存着最常用的数据。靠近CPU的小的、快速的高速缓存存储器(cache memory)作为一部分存储在相对慢速的主存储器(main memory)中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为存储在通过网络连接的其他机器的磁盘或磁带上的数据的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-1.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-2.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-3.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-4.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-5.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-6.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-7.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-8.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-9.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/formula1.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/example1.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-10.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/formula2.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/formula3.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/example2.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-11.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-12.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-13.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-14.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-15.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-16.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-17.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-18.png">
<meta property="og:image" content="https://lu0k.github.io/posts/mem-hier1/6-19.png">
<meta property="article:published_time" content="2022-02-04T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-16T11:00:17.988Z">
<meta property="article:author" content="Lu0k">
<meta property="article:tag" content="CSAPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lu0k.github.io/posts/mem-hier1/6-1.png">


<link rel="canonical" href="https://lu0k.github.io/posts/mem-hier1/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lu0k.github.io/posts/mem-hier1/","path":"posts/mem-hier1/","title":"存储器层次结构(一)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>存储器层次结构(一) | Lu0k</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Lu0k</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Lu0k's Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">内容简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"><span class="nav-number">2.</span> <span class="nav-text">存储技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">随机访问存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81RAM"><span class="nav-number">2.1.1.</span> <span class="nav-text">静态RAM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81RAM"><span class="nav-number">2.1.2.</span> <span class="nav-text">动态RAM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84DRAM"><span class="nav-number">2.1.3.</span> <span class="nav-text">传统的DRAM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9D%97"><span class="nav-number">2.1.4.</span> <span class="nav-text">内存模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84DRAM"><span class="nav-number">2.1.5.</span> <span class="nav-text">增强的DRAM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">2.1.6.</span> <span class="nav-text">非易失性存储器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E4%B8%BB%E5%AD%98"><span class="nav-number">2.1.7.</span> <span class="nav-text">访问主存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8"><span class="nav-number">2.2.</span> <span class="nav-text">磁盘存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E6%9E%84%E9%80%A0"><span class="nav-number">2.2.1.</span> <span class="nav-text">磁盘构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F"><span class="nav-number">2.2.2.</span> <span class="nav-text">磁盘容量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.3.</span> <span class="nav-text">磁盘操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%A3%81%E7%9B%98%E5%9D%97"><span class="nav-number">2.2.4.</span> <span class="nav-text">逻辑磁盘块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5I-x2F-O%E8%AE%BE%E5%A4%87"><span class="nav-number">2.2.5.</span> <span class="nav-text">连接I&#x2F;O设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E7%A3%81%E7%9B%98"><span class="nav-number">2.2.6.</span> <span class="nav-text">访问磁盘</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="nav-number">2.3.</span> <span class="nav-text">固态硬盘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF"><span class="nav-number">2.4.</span> <span class="nav-text">存储技术趋势</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">局部性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%A8%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BC%95%E7%94%A8%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-number">3.1.</span> <span class="nav-text">对程序数据引用的局部性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%96%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-number">3.2.</span> <span class="nav-text">取指令的局部性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%B0%8F%E7%BB%93"><span class="nav-number">3.3.</span> <span class="nav-text">局部性小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">4.</span> <span class="nav-text">Reference</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lu0k"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Lu0k</p>
  <div class="site-description" itemprop="description">谦虚学习!</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">157</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lu0k" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lu0k" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Lu0kMe" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Lu0kMe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lu0k.github.io/posts/mem-hier1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Lu0k">
      <meta itemprop="description" content="谦虚学习!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lu0k">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          存储器层次结构(一)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-05 00:00:00" itemprop="dateCreated datePublished" datetime="2022-02-05T00:00:00+08:00">2022-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Read-Notes/" itemprop="url" rel="index"><span itemprop="name">Read Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><p>存储器系统<code>(memory system)</code>是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU寄存器保存着最常用的数据。靠近CPU的小的、快速的高速缓存存储器<code>(cache memory)</code>作为一部分存储在相对慢速的主存储器<code>(main memory)</code>中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为存储在通过网络连接的其他机器的磁盘或磁带上的数据的缓冲区域。</p>
<span id="more"></span>

<p>存储器层次结构是可行的，这是因为与下一个更低层次的存储设备相比来说，一个编写良好的程序倾向于更频繁地访问某一个层次上的存储设备。所以，下一层的存储设备可以更慢速一点，也因此可以更大，每个比特位更便宜。整体效果是一个大的存储器池，其成本与层次结构底层最便宜的存储设备相当，但是却以接近于层次结构顶部存储设备的高速率向程序提供数据。</p>
<p>作为一个程序员，你需要理解存储器层次结构，因为它对应用程序的性能有着巨大的影响。如果你的程序需要的数据是存储在CPU寄存器中的，那么在指令的执行期间，在0个周期内就能访问到它们。如果存储在高速缓存中，需要<code>4~75</code>个周期。如果存储在主存中，需要上百个周期。而如果存储在磁盘上，需要大约几千万个周期！</p>
<p>这里就是计算机系统中一个基本而持久的思想：如果你理解了系统是如何将数据在存储器层次结构中上上下下移动的，那么你就可以编写自己的应用程序，使得它们的数据项存储在层次结构中较高的地方，在那里CPU能更快地访问到它们。</p>
<p>这个思想围绕着计算机程序的一个称为局部性<code>(locality)</code>的基本属性。具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或是倾向于访问邻近的数据项集合。具有良好局部性的程序比局部性差的程序更多地倾向于从存储器层次结构中较高层次处访问数据项，因此运行得更快。例如，在<code>Core i7</code>系统，不同的矩阵乘法核心程序执行相同数量的算术操作，但是有不同程度的局部性，它们的运行时间可以相差40倍！</p>
<p>在本章中，我们会看看基本的存储技术——<code>SRAM</code>存储器、<code>DRAM</code>存储器、<code>ROM</code>存储器以及旋转的和固态的硬盘——并描述它们是如何被组织成层次结构的。特别地，我们将注意力集中在高速缓存存储器上，它是作为CPU和主存之间的缓存区域，因为它们对应用程序性能的影响最大。我们向你展示如何分析C程序的局部性，并且介绍改进你的程序中局部性的技术。</p>
<h1 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h1><p>计算机技术的成功很大程度上源自于存储技术的巨大进步。早期的计算机只有几千字节的随机访问存储器。最早的<code>IBM PC</code>甚至于没有硬盘。1982年引入的<code>IBM PC-XT</code>有10M字节的磁盘。到2015年，典型的计算机已有300000倍于<code>PC-XT</code>的磁盘存储，而且磁盘的容量以每两年加倍的速度增长。</p>
<h2 id="随机访问存储器"><a href="#随机访问存储器" class="headerlink" title="随机访问存储器"></a>随机访问存储器</h2><p>随机访问存储器<code>(Random-Access Memory, RAM)</code>分为两类：静态的和动态的。静态<code>RAM(SRAM)</code>比动态<code>RAM(DRAM)</code>更快，但也贵得多。<code>SRAM</code>用来作为高速缓存存储器，既可以在<code>CPU</code>芯片上，也可以在片下。<code>DRAM</code>用来作为主存以及图形系统的帧缓冲区。典型地，一个桌面系统的<code>SRAM</code>不会超过几兆字节，但是<code>DRAM</code>却有几百或几千兆字节。</p>
<h3 id="静态RAM"><a href="#静态RAM" class="headerlink" title="静态RAM"></a>静态RAM</h3><p><code>SRAM</code>将每个位存储在一个双稳态的<code>(bistable)</code>存储器单元里。每个单元是用一个六晶体管电路来实现的。这个电路有这样一个属性，它可以无限期地保持在两个不同的电压配置<code>(configuration)</code>或状态<code>(state)</code>之一。其他任何状态都是不稳定的——从不稳定状态开始，电路会迅速地转移到两个稳定状态中的一个。这样一个存储器单元类似于图<code>6-1</code>中画出的倒转的钟摆。</p>
<p><img src="/posts/mem-hier1/6-1.png"></p>
<p>当钟摆倾斜到最左边或最右边时，它是稳定的。从其他任何位置，钟摆都会倒向一边或另一边。原则上，钟摆也能在垂直的位置无限期地保持平衡，但是这个状态是亚稳态的<code>(metastable)</code>——最细微的扰动也能使它倒下，而且一旦倒下就永远不会再恢复到垂直的位置。</p>
<p>由于<code>SRAM</code>存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。即使有干扰<code>(例如电子噪音)</code>来扰乱电压，当干扰消除时，电路就会恢复到稳定值。</p>
<h3 id="动态RAM"><a href="#动态RAM" class="headerlink" title="动态RAM"></a>动态RAM</h3><p><code>DRAM</code>将每个位存储为对一个电容的充电。这个电容非常小，通常只有大约30毫微微法拉<code>(femtofarad)</code>——30x10<sup>-15</sup>法拉。不过，回想一下法拉是一个非常大的计量单位。<code>DRAM</code>存储器可以制造得非常密集——每个单元由一个电容和一个访问晶体管组成。但是，与<code>SRAM</code>不同，<code>DRAM</code>存储器单元对干扰非常敏感。当电容的电压被扰乱之后，它就永远不会恢复了。暴露在光线下会导致电容电压改变。实际上，数码照相机和摄像机中的传感器本质上就是<code>DRAM</code>单元的阵列。</p>
<p>很多原因会导致漏电，使得<code>DRAM</code>单元在<code>10~100</code>毫秒时间内失去电荷。幸运的是，计算机运行的时钟周期是以纳秒来衡量的，所以相对而言这个保持时间是比较长的。内存系统必须周期性地通过读出，然后重写来刷新内存每一位。有些系统也使用纠错码，其中计算机的字会被多编码几个位<code>(例如64位的字可能用72位来编码)</code>，这样一来，电路可以发现并纠正一个字中任何单个的错误位。</p>
<p>图<code>6-2</code>总结了<code>SRAM</code>和<code>DRAM</code>存储器的特性。只要有供电，<code>SRAM</code>就会保持不变。与<code>DRAM</code>不同，它不需要刷新。<code>SRAM</code>的存取比<code>DRAM</code>快。<code>SRAM</code>对诸如光和电噪声这样的干扰不敏感。代价是<code>SRAM</code>单元比<code>DRAM</code>单元使用更多的晶体管，因而密集度低，而且更贵，功耗更大。</p>
<p><img src="/posts/mem-hier1/6-2.png"></p>
<h3 id="传统的DRAM"><a href="#传统的DRAM" class="headerlink" title="传统的DRAM"></a>传统的DRAM</h3><p><code>DRAM</code>芯片中的单元<code>(位)</code>被分成<code>d</code>个超单元<code>(supercell)</code>，每个超单元都由<code>w</code>个<code>DRAM</code>单元组成。一个<code>dxw</code>的<code>DRAM</code>总共存储了<code>dw</code>位信息。超单元被组织成一个<code>r</code>行<code>c</code>列的长方形阵列，这里<code>rc=d</code>。每个超单元有形如<code>(i,j)</code>的地址，这里<code>i</code>表示行，而<code>j</code>表示列。</p>
<p>例如，图<code>6-3</code>展示的是一个<code>16x8</code>的<code>DRAM</code>芯片的组织，有<code>d=16</code>个超单元，每个超单元有<code>ω=8</code>位，<code>r=4</code>行，<code>c=4</code>列。带阴影的方框表示地址<code>(2,1)</code>处的超单元。信息通过称为引脚<code>(pin)</code>的外部连接器流入和流出芯片。每个引脚携带一个1位的信号。图<code>6-3</code>给出了两组引脚：8个<code>data</code>引脚，它们能传送一个字节到芯片或从芯片传出一个字节，以及2个<code>addr</code>引脚，它们携带2位的行和列超单元地址。其他携带控制信息的引脚没有显示出来。</p>
<p><img src="/posts/mem-hier1/6-3.png"></p>
<p>每个<code>DRAM</code>芯片被连接到某个称为内存控制器<code>(memory controller)</code>的电路，这个电路可以一次传送<code>ω</code>位到每个<code>DRAM</code>芯片或一次从每个<code>DRAM</code>芯片传出<code>ω</code>位。为了读出超单元<code>(i,j)</code>的内容，内存控制器将行地址<code>i</code>发送到<code>DRAM</code>，然后是列地址<code>j</code>。<code>DRAM</code>把超单元<code>(i,j)</code>的内容发回给控制器作为响应。行地址<code>i</code>称为<code>RAS(Row Access Strobe, 行访向选通脉冲)</code>请求。列地址<code>j</code>称为<code>CAS(Column Access Strobe, 列访问选通脉冲)</code>请求。注意，<code>RAS</code>和<code>CAS</code>请求共享相同的<code>DRAM</code>地址引脚。</p>
<p>例如，要从图<code>6-3</code>中<code>16x8</code>的<code>DRAM</code>中读出超单元<code>(2,1)</code>，内存控制器发送行地址<code>2</code>，如图<code>6-4a</code>所示。<code>DRAM</code>的响应是将行<code>2</code>的整个内容都复制到一个内部行缓冲区。接下来，内存控制器发送列地址<code>1</code>，如图<code>6-4b</code>所示。<code>DRAM</code>的响应是从行缓冲区复制出超单元<code>(2,1)</code>中的8位，并把它们发送到内存控制器。</p>
<p><img src="/posts/mem-hier1/6-4.png"></p>
<p>电路设计者将<code>DRAM</code>组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。例如，如果示例的128位<code>DRAM</code>被组织成一个16个超单元的线性数组，地址为<code>0~15</code>，那么芯片会需要4个地址引脚而不是2个。二维阵列组织的缺点是必须分两步发送地址，这增加了访问时间。</p>
<h3 id="内存模块"><a href="#内存模块" class="headerlink" title="内存模块"></a>内存模块</h3><p><code>DRAM</code>芯片封装在内存模块<code>(memory module)</code>中，它插到主板的扩展槽上。<code>Core i7</code>系统使用的240个引脚的双列直插内存模块<code>(Dual Inline Memory Module,DIMM)</code>，它以64位为块传送数据到内存控制器和从内存控制传出数据。</p>
<p>图<code>6-5</code>展示了一个内存模块的基本思想。示例模块用8个64Mbit的<code>8MX8</code>的<code>DRAM</code>芯片，总共存储64MB<code>(兆字节)</code>，这8个芯片编号为<code>0~7</code>。每个超单元存储主存的一个字节，而用相应超单元地址为<code>(i,j)</code>的8个超单元来表示主存中字节地址A处的64位字。在图<code>6-5</code>的示例中，<code>DRAM 0</code>存储第一个<code>(低位)</code>字节，<code>DRAM 1</code>存储下一个字节，依此类推。</p>
<p>要取出内存地址<code>A</code>处的一个字，内存控制器将<code>A</code>转换成一个超单元地址<code>(i,j)</code>，并将它发送到内存模块，然后内存模块再将<code>i</code>和<code>j</code>广播到每个<code>DRAM</code>。作为响应，每个<code>DRAM</code>输出它的<code>(i,j)</code>超单元的8位内容。模块中的电路收集这些输出，并把它们合并成一个64位字，再返回给内存控制器。</p>
<p>通过将多个内存模块连接到内存控制器，能够聚合成主存。在这种情况中，当控制器收到一个地址<code>A</code>时，控制器选择包含<code>A</code>的模块<code>k</code>，将<code>A</code>转换成它的<code>(i,j)</code>的形式，并将<code>(i,j)</code>发送到模块<code>k</code>。</p>
<p><img src="/posts/mem-hier1/6-5.png"></p>
<h3 id="增强的DRAM"><a href="#增强的DRAM" class="headerlink" title="增强的DRAM"></a>增强的DRAM</h3><p>有许多种<code>DRAM</code>存储器，而生产厂商试图跟上迅速增长的处理器速度，市场上就会定期推出新的种类。每种都是基于传统的<code>DRAM</code>单元，并进行一些优化，提高访问基本<code>DRAM</code>单元的速度。</p>
<ul>
<li>快页模式<code>DRAM(Fast Page Mode DRAM, FPM DRAM)</code>。传统的<code>DRAM</code>将超单元的一整行复制到它的内部行缓冲区中，使用一个，然后丢弃剩余的。<code>FPM DRAM</code>允许对同一行连续地访问可以直接从行缓冲区得到服务，从而改进了这一点。例如，要从一个传统的<code>DRAM</code>的行<code>i</code>中读4个超单元，内存控制器必须发送4个<code>RAS/CAS</code>请求，即使是行地址<code>i</code>在每个情况中都是一样的。要从一个<code>FPM DRAM</code>的同一行中读取超单元，内存控制器发送第一个<code>RAS/CAS</code>请求，后面跟三个<code>CAS</code>请求。初始的<code>RAS/CAS</code>请求将行<code>i</code>复制到行缓冲区，并返回<code>CAS</code>寻址的那个超单元。接下来三个超单元直接从行缓冲区获得，因此返回得比初始的超单元更快</li>
<li>扩展数据输出<code>DRAM(Extended Data Out DRAM, EDO DRAM)</code>。<code>FPM DRAM</code>的一个增强的形式，它允许各个<code>CAS</code>信号在时间上靠得更紧密一点</li>
<li>同步<code>DRAM(Synchironous DRAM, SDRAM)</code>。就它们与内存控制器通信使用一组显式的控制信号来说，常规的、<code>FPM</code>和<code>EDO DRAM</code>都是异步的。<code>SDRAM</code>用与驱动内存控制器相同的外部时钟信号的上升沿来代替许多这样的控制信号。我们不会深入讨论细节，最终效果就是<code>SDRAM</code>能够比那些异步的存储器更快地输出它的超单元的内容</li>
<li>双倍数据速率同步<code>DRAM(Double Data-Rate Synchronous DRAM, DDR SDRAM)</code>。<code>DDR SDRAM</code>是对<code>SDRAM</code>的一种增强，它通过使用两个时钟沿作为控制信号，从而使<code>DRAM</code>的速度翻倍。不同类型的<code>DDR SDRAM</code>是用提高有效带宽的很小的预取缓冲区的大小来划分的：<code>DDR(2位)</code>、<code>DDR2(4位)</code>和<code>DDR3(8位)</code></li>
<li>视频<code>RAM(Video RAM, VRAM)</code>。它用在图形系统的帧缓冲区中。<code>VRAM</code>的思想与<code>FPM DRAM</code>类似。两个主要区别是：<code>VRAM</code>的输出是通过依次对内部缓冲区的整个内容进行移位得到；<code>VRAM</code>允许对内存并行地读和写。因此，系统可以在写下一次更新的新值<code>(写)</code>的同时，用帧缓冲区中的像素刷屏幕<code>(读)</code></li>
</ul>
<h3 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h3><p>如果断电，<code>DRAM</code>和<code>SRAM</code>会丢失它们的信息，从这个意义上说，它们是易失的<code>(volatile)</code>。另一方面，非易失性存储器<code>(nonvolatile memory)</code>即使是在关电后，仍然保存着它们的信息。现在有很多种非易失性存储器。由于历史原因，虽然<code>ROM</code>中有的类型既可以读也可以写，但是它们整体上都被称为只读存储器<code>(Read-Only Memory, ROM)</code>。<code>ROM</code>是以它们能够被重编程<code>(写)</code>的次数和对它们进行重编程所用的机制来区分的。</p>
<p><code>PROM(Programmable ROM, 可编程ROM)</code>只能被编程一次。<code>PROM</code>的每个存储器单元有一种熔丝<code>(fuse)</code>，只能用高电流熔断一次。</p>
<p>可擦写可编程<code>ROM(Erasable Programmable ROM, EPROM)</code>有一个透明的石英窗口，允许光到达存储单元。紫外线光照射过窗口，<code>EPROM</code>单元就被清除为0。对<code>EPROM</code>编程是通过使用一种把1写入<code>EPROM</code>的特殊设备来完成的。<code>EPROM</code>能够被擦除和重编程的次数的数量级可以达到1000次。电子可擦除<code>PROM(Electrically Erasable PROM, EEPROM)</code>类似于<code>EPROM</code>，但是它不需要一个物理上独立的编程设备，因此可以直接在印制电路卡上编程。<code>EEPROM</code>能够被编程的次数的数量级可以达到105次。</p>
<p>闪存<code>(flash memory)</code>是一类非易失性存储器，基于<code>EEPROM</code>，它已经成为了一种重要的存储技术。闪存无处不在，为大量的电子设备提供快速而持久的非易失性存储，包括数码相机、手机、音乐播放器、<code>PDA</code>和笔记本、台式机和服务器计算机系统。在<code>6.1.3</code>节中，我们会仔细研究一种新型的基于闪存的磁盘驱动器，称为固态硬盘<code>(Solid State Disk, SSD)</code>，它能提供相对于传统旋转磁盘的一种更快速、更强健和更低能耗的选择。</p>
<p>存储在<code>ROM</code>设备中的程序通常被称为固件<code>(firmware)</code>。当一个计算机系统通电以后，它会运行存储在<code>ROM</code>中的固件。一些系统在固件中提供了少量基本的输入和输出数——例如<code>PC</code>的<code>BIOS(基本输入/输出系统)</code>例程。复杂的设备，像图形卡和磁盘驱动控制器，也依赖固件翻译来自<code>CPU</code>的<code>I/O(输入/输出)</code>请求。</p>
<h3 id="访问主存"><a href="#访问主存" class="headerlink" title="访问主存"></a>访问主存</h3><p>数据流通过称为总线<code>(bus)</code>的共享电子电路在处理器和<code>DRAM</code>主存之间来来回回。每次<code>CPU</code>和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为总线事务<code>(bustransaction)</code>。读事务<code>(read transaction)</code>从主存传送数据到<code>CPU</code>。写事务<code>(write transaction)</code>从<code>CPU</code>传送数据到主存。</p>
<p>总线是一组并行的导线，能携带地址、数据和控制信号。取决于总线的设计，数据和地址信号可以共享同一组导线，也可以使用不同的。同时，两个以上的设备也能共享同一总线。控制线携带的信号会同步事务，并标识出当前正在被执行的事务的类型。例如，当前关注的这个事务是到主存的吗？还是到诸如磁盘控制器这样的其他<code>I/O</code>设备？这个事务是读还是写？总线上的信息是地址还是数据项？</p>
<p>图<code>6-6</code>展示了一个示例计算机系统的配置。主要部件是<code>CPU</code>芯片、我们将称为<code>I/O</code>桥接器<code>(I/O bridge)</code>的芯片组<code>(其中包括内存控制器)</code>，以及组成主存的<code>DRAM</code>内存模块。这些部件由一对总线连接起来，其中一条总线是系统总线<code>(system bus)</code>，它连接<code>CPU</code>和<code>I/O</code>桥接器，另一条总线是内存总线<code>(memory bus)</code>，它连接<code>I/O</code>桥接器和主存。<code>I/O</code>桥接器将系统总线的电子信号翻译成内存总线的电子信号。正如我们看到的那样，<code>I/O</code>桥也将系统总线和内存总线连接到<code>I/O</code>总线，像磁盘和图形卡这样的<code>I/O</code>设备共享<code>I/O</code>总线。不过现在，我们将注意力集中在内存总线上。</p>
<p><img src="/posts/mem-hier1/6-6.png"></p>
<p>考虑当<code>CPU</code>执行一个如下加载操作时会发生什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq A,%rax</span><br></pre></td></tr></table></figure>

<p>这里，地址<code>A</code>的内容被加载到寄存器<code>%rax</code>中。<code>CPU</code>芯片上称为总线接口<code>(bus interface)</code>的电路在总线上发起读事务。读事务是由三个步骤组成的。首先，<code>CPU</code>将地址<code>A</code>放到系统总线上。<code>I/O</code>桥将信号传递到内存总线<code>(图6-7a)</code>。接下来，主存感觉到内存总线上的地址信号，从内存总线读地址，从<code>DRAM</code>取出数据字，并将数据写到内存总线。<code>I/O</code>桥将内存总线信号翻译成系统总线信号，然后沿着系统总线传递<code>(图6-7b)</code>。最后，<code>CPU</code>感觉到系统总线上的数据，从总线上读数据，并将数据复制到寄存器<code>%rax(图6-7c)</code>。</p>
<p><img src="/posts/mem-hier1/6-7.png"></p>
<p>反过来，当<code>CPU</code>执行一个像下面这样的存储操作时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movq %rax,A</span><br></pre></td></tr></table></figure>

<p>这里，寄存器<code>%rax</code>的内容被写到地址<code>A</code>，<code>CPU</code>发起写事务。同样，有三个基本步骤。首先，<code>CPU</code>将地址放到系统总线上。内存从内存总线读出地址，并等待数据到达<code>(图6-8a)</code>。接下来，<code>CPU</code>将<code>%rax</code>中的数据字复制到系统总线<code>(图6-8b)</code>。最后，主存从内存总线读出数据字，并且将这些位存储到<code>DRAM</code>中<code>(图6-8c)</code>。</p>
<h2 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h2><p>磁盘是广为应用的保存大量数据的存储设备，存储数据的数量级可以达到几百到几千千兆字节，而基于<code>RAM</code>的存储器只能有几百或几千兆字节。不过，从磁盘上读信息的时间为毫秒级，比从<code>DRAM</code>读慢了10万倍，比从<code>SRAM</code>读慢了100万倍。</p>
<p><img src="/posts/mem-hier1/6-8.png"></p>
<h3 id="磁盘构造"><a href="#磁盘构造" class="headerlink" title="磁盘构造"></a>磁盘构造</h3><p>磁盘是由盘片<code>(platter)</code>构成的。每个盘片有两面或者称为表面<code>(surface)</code>，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴<code>(spindle)</code>，它使得盘片以固定的旋转速率<code>(rotational rate)</code>旋转，通常是<code>5400~15000</code>转每分钟<code>(Revolution Per Minute, RPM)</code>。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。</p>
<p>图<code>6-9a</code>展示了一个典型的磁盘表面的结构。每个表面是由一组称为磁道<code>(track)</code>的同心圆组成的。每个磁道被划分为一组扇区<code>(sector)</code>。每个扇区包含相等数量的数据位<code>(通常是512字节)</code>，这些数据编码在扇区上的磁性材料中。扇区之间由一些间隙<code>(gap)</code>分隔开，这些间隙中不存储数据位。间隙存储用来标识扇区的格式化位。</p>
<p>磁盘是由一个或多个叠放在一起的盘片组成的，它们被封装在一个密封的包装里，如图<code>6-9b</code>所示。整个装置通常被称为磁盘驱动器<code>(disk drive)</code>，我们通常简称为磁盘<code>(disk)</code>。有时，我们会称磁盘为旋转磁盘<code>(rotating disk)</code>，以使之区别于基于闪存的固态硬盘<code>(SSD)</code>，<code>SSD</code>是没有移动部分的。</p>
<p>磁盘制造商通常用术语柱面<code>(cylinder)</code>来描述多个盘片驱动器的构造，这里，柱面是所有盘片表面上到主轴中心的距离相等的磁道的集合。例如，如果一个驱动器有三个盘片和六个面，每个表面上的磁道的编号都是一致的，那么柱面<code>k</code>就是6个磁道<code>k</code>的集合。</p>
<p><img src="/posts/mem-hier1/6-9.png"></p>
<h3 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h3><p>一个磁盘上可以记录的最大位数称为它的最大容量，或者简称为容量。磁盘容量是由以下技术因素决定的：</p>
<ul>
<li><p>记录密度<code>(recording density)(位/英寸)</code>：磁道一英寸的段中可以放入的位数</p>
</li>
<li><p>磁道密度<code>(track density)(道/英寸)</code>：从盘片中心出发半径上一英寸的段内可以有的磁道数</p>
</li>
<li><p>面密度<code>(areal density)(位/平方英寸)</code>：记录密度与磁道密度的乘积</p>
</li>
</ul>
<p>磁盘制造商不懈地力以提高面密度<code>(从而增加容量)</code>，而面密度每隔几年就会翻倍。最初的磁盘，是在面密度很低的时代设计的，将每个磁道分为数目相同的扇区，扇区的数目是由最靠内的磁道能记录的扇区数决定的。为了保持每个磁道有固定的扇区数，越往外的磁道扇区隔得越开。在面密度相对比较低的时候，这种方法还算合理。不过，随着面密度的提高，扇区之间的间隙<code>(那里没有存储数据位)</code>得不可接受地大。因此，现代大容量磁盘使用一种称为多区记录<code>(multiple zone recording)</code>的技术，在这种技术中，柱面的集合被分割成不相交子集合，称为记录区<code>(recording zone)</code>。每个区包含一组连续的柱面。一个区中的每个柱面中的每条磁道都有相同数量的扇区，这个扇区的数量是由该区中最里面的磁道所能包含的扇区数确定的。</p>
<p>下面的公式给出了一个磁盘的容量：</p>
<p><img src="/posts/mem-hier1/formula1.png"></p>
<p>例如，假设我们有一个磁盘，有5个盘片，每个扇区512个字节，每个面20000条磁道，每条磁道平均300个扇区。那么这个磁盘的容量是：</p>
<p><img src="/posts/mem-hier1/example1.png"></p>
<p>注意，制造商是以千兆字节<code>(GB)</code>或兆兆字节<code>(TB)</code>为单位来表达磁盘容量的，这里1GB&#x3D;10<sup>9</sup>字节，1TB&#x3D;10<sup>12</sup>字节。</p>
<h3 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h3><p>磁盘用读<code>/</code>写头<code>(read/write head)</code>来读写存储在磁性表面的位，而读写头连接到一个传动臂<code>(actuator arm)</code>一端，如图<code>6-10a</code>所示。通过沿着半径轴前后移动这个传动臂，驱动器可以将读<code>/</code>写头定位在盘面上的任何磁道上。这样的机械运动称为寻道<code>(seek)</code>。一旦读<code>/</code>写头定位到了期望的磁道上，那么当磁道上的每个位通过它的下面时，读<code>/</code>写头可以感知到这个位的值<code>(读该位)</code>，也可以修改这个位的值<code>(写该位)</code>。有多个盘片的磁盘针对每个盘面都有一个独立的读<code>/</code>写头，如图<code>6-10b</code>所示。读<code>/</code>写头垂直排列，一致行动。在任何时刻，所有的读<code>/</code>写头都位于同一个柱面上。</p>
<p><img src="/posts/mem-hier1/6-10.png"></p>
<p>在传动臂末端的读<code>/</code>写头在磁盘表面高度大约0.1微米处的一层薄薄的气垫上飞翔<code>(就是字面上这个意思)</code>，速度大约为80km&#x2F;h。这可以比喻成将一座摩天大楼<code>(442米高)</code>放倒，然后让它在距离地面2.5cm<code>(1英寸)</code>的高度上环绕地球飞行，绕地球一周只需要8秒钟！在这样小的间隙里，盘面上一粒微小的灰尘都像一块巨石。如果读<code>/</code>写头碰到了这样的一块巨石，读<code>/</code>写头会停下来，撞到盘面——所谓的读<code>/</code>写头冲撞<code>(head crash)</code>。为此，磁盘总是密封包装的。</p>
<p>磁盘以扇区大小的块来读写数据。对扇区的访问时间<code>(access time)</code>有三个主要的部分：寻道时间<code>(seek time)</code>、旋转时间<code>(rotational latency)</code>和传送时间<code>(transfer time)</code>：</p>
<ul>
<li>寻道时间：为了读取某个目标扇区的内容，传动臂首先将读<code>/</code>写头定位到包含目标扇区的磁道上。移动传动臂所需的时间称为寻道时间。寻道时间T<sub>seek</sub>依赖于读<code>/</code>写头以前的位置和传动臂在盘面上移动的速度。现代驱动器中平均寻道时间T<sub>avg seek</sub>是通过对几千次对随机扇区的寻道求平均值来测量的，通常为<code>3~9ms</code>。一次寻道的最大时间T<sub>max seek</sub>可以高达20ms</li>
<li>旋转时间：一旦读<code>/</code>写头定位到了期望的磁道，驱动器等待目标扇区的第一个位旋转到读<code>/</code>写头下。这个步骤的性能依赖于当读<code>/</code>写头到达目标扇区时盘面的位置以及磁盘的旋转速度。在最坏的情况下，读<code>/</code>写头刚刚错过了目标扇区，必须等待磁盘转一整圈。因此，最大旋转延迟<code>(以秒为单位)</code>是</li>
</ul>
<p><img src="/posts/mem-hier1/formula2.png"></p>
<ul>
<li>传送时间：当目标扇区的第一个位位于读<code>/</code>写头下时，驱动器就可以开始读或者写该扇区的内容了。一个扇区的传送时间依赖于旋转速度和每条磁道的扇区数目。因此，我们可以粗略地估计一个扇区以秒为单位的平均传送时间如下</li>
</ul>
<p><img src="/posts/mem-hier1/formula3.png"></p>
<p>我们可以估计访问一个磁盘扇区内容的平均时间为平均寻道时间、平均旋转延迟和平均传送时间之和。例如，考虑一个有如下参数的磁盘：</p>
<p><img src="/posts/mem-hier1/example2.png"></p>
<p>这个例子说明了一些很重要的问题：</p>
<ul>
<li><p>访问一个磁盘扇区中512个字节的时间主要是寻道时间和旋转延迟。访问扇区中的第一个字节用了很长时间，但是访问剩下的字节几乎不用时间</p>
</li>
<li><p>因为寻道时间和旋转延迟大致相等，所以将寻道时间乘2是估计磁盘访问时间的简单而合理的方法</p>
</li>
<li><p>对存储在<code>SRAM</code>中的一个64位字的访问时间大约是4ns，对<code>DRAM</code>的访问时间是60ns。因此，从内存中读一个512个字节扇区大小的块的时间对<code>SRAM</code>来说大约是256ns，对<code>DRAM</code>来说大约是4000ns。磁盘访问时间，大约10ms，是<code>SRAM</code>的大约40000倍，是<code>DRAM</code>的大约2500倍</p>
</li>
</ul>
<h3 id="逻辑磁盘块"><a href="#逻辑磁盘块" class="headerlink" title="逻辑磁盘块"></a>逻辑磁盘块</h3><p>正如我们看到的那样，现代磁盘构造复杂，有多个盘面，这些盘面上有不同的记录区。为了对操作系统隐藏这样的复杂性，现代磁盘将它们的构造呈现为一个简单的视图，一个<code>B</code>个扇区大小的逻辑块的序列，编号为<code>0,1,···,B-1</code>。磁盘封装中有一个小的硬件<code>/</code>固件设备，称为磁盘控制器，维护着逻辑块号和实际<code>(物理)</code>磁盘扇区之间的映射关系。</p>
<p>当操作系统想要执行一个<code>I/O</code>操作时，例如读一个磁盘扇区的数据到主存，操作系统会发送一个命令到磁盘控制器，让它读某个逻辑块号。控制器上的固件执行一个快速表查找，将一个逻辑块号翻译成一个<code>(盘面，磁道，扇区)</code>的三元组，这个三元组唯一地标识了对应的物理扇区。控制器上的硬件会解释这个三元组，将读<code>/</code>写头移动到适当的柱面，等待扇区移动到读<code>/</code>写头下，将读<code>/</code>写头感知到的位放到控制器上的一个小缓冲区中，然后将它们复制到主存中。</p>
<h3 id="连接I-x2F-O设备"><a href="#连接I-x2F-O设备" class="headerlink" title="连接I&#x2F;O设备"></a>连接I&#x2F;O设备</h3><p>例如图形卡、监视器、鼠标、键盘和磁盘这样的输入<code>/</code>输出<code>(I/O)</code>设备，都是通过<code>I/O</code>总线，例如<code>Intel</code>的外围设备互连<code>(Peripheral Component Interconnect, PCI)</code>总线连接到<code>CPU</code>和主存的。系统总线和内存总线是与<code>CPU</code>相关的，与它们不同，诸如<code>PCI</code>这样的<code>I/O</code>总线设计成与底层<code>CPU</code>无关。例如，<code>PC</code>和<code>Mac</code>都可以使用<code>PCI</code>总线。图<code>6-11</code>展示了一个典型的<code>I/O</code>总线结构，它连接了<code>CPU</code>、主存和<code>I/O</code>设备。</p>
<p>虽然<code>I/O</code>总线比系统总线和内存总线慢，但是它可以容纳种类繁多的第三方<code>I/O</code>设备。例如，在图<code>6-11</code>中，有三种不同类型的设备连接到总线：</p>
<ul>
<li><p>通用串行总线<code>(Universal Serial Bus, USB)</code>控制器是一个连接到<code>USB</code>总线的设备的中转机构，<code>USB</code>总线是一个广泛使用的标准，连接各种外围<code>I/O</code>设备，包括键盘、鼠标、调制解调器、数码相机、游戏操纵杆、打印机、外部磁盘驱动器和固态硬盘。<code>USB 3.0</code>总线的最大带宽为625MB&#x2F;s。<code>USB 3.1</code>总线的最大带宽为1250MB&#x2F;s</p>
</li>
<li><p>图形卡<code>(或适配器)</code>包含硬件和软件逻辑，它们负责代表<code>CPU</code>在显示器上画像素</p>
</li>
<li><p>主机总线适配器将一个或多个磁盘连接到<code>I/O</code>总线，使用的是一个特别的主机总线接口定义的通信协议。两个最常用的这样的磁盘接口是<code>SCSI(读作&quot;scuzzy&quot;)</code>和<code>SATA(读作&quot;sat-uh&quot;)</code>。<code>SCSI</code>磁盘通常比<code>SATA</code>驱动器更快但是也更贵。<code>SCSI</code>主机总线适配器<code>(通常称为SCSI控制器)</code>可以支持多个磁盘驱动器，而<code>SATA</code>适配器与之不同，只能支持一个驱动器</p>
</li>
</ul>
<p><img src="/posts/mem-hier1/6-11.png"></p>
<p>其他的设备，例如网络适配器，可以通过将适配器插入到主板上空的扩展槽中，从而连接到<code>I/O</code>总线，这些插槽提供了到总线的直接电路连接。</p>
<h3 id="访问磁盘"><a href="#访问磁盘" class="headerlink" title="访问磁盘"></a>访问磁盘</h3><p>虽然详细描述<code>I/O</code>设备是如何工作的以及如何对它们进行编程超出了我们讨论的范围，但是我们可以给你一个概要的描述。例如，图<code>6-12</code>总结了当<code>CPU</code>从磁盘读数据时发生的步骤。</p>
<p><code>CPU</code>使用一种称为内存映射<code>I/O(memory-mapped I/O)</code>的技术来向<code>I/O</code>设备发射命令<code>(图6-12a)</code>。在使用内存映射<code>I/O</code>的系统中，地址空间中有一块地址是为与<code>I/O</code>设备通信保留的。每个这样的地址称为一个<code>I/O</code>端口<code>(I/O port)</code>。当一个设备连接到总线时，它与一个或多个端口相关联<code>(或它被映射到一个或多个端口)</code>。</p>
<p><img src="/posts/mem-hier1/6-12.png"></p>
<p>来看一个简单的例子，假设磁盘控制器映射到端口<code>0xa0</code>。随后，<code>CPU</code>可能通过执行三个对地址 <code>0xa0</code>的存储指令，发起磁盘读：第一条指令是发送一个命令字，告诉磁盘发起一个读，同时还发送了其他的参数，例如当读完成时，是否中断<code>CPU(我们会在8.1节中讨论中断)</code>。第二条指令指明应该读的逻辑块号。第三条指令指明应该存储磁盘扇区内容的主存地址。</p>
<p>当<code>CPU</code>发出了请求之后，在磁盘执行读的时候，它通常会做些其他的工作。回想一下，一个<code>1GHz</code>的处理器时钟周期为1ns，在用来读磁盘的16ms时间里，它潜在地可能执行1600万条指令。在传输进行时，只是简单地等待，什么都不做，是一种极大的浪费。</p>
<p>在磁盘控制器收到来自<code>CPU</code>的读命令之后，它将逻辑块号翻译成一个扇区地址，读该扇区的内容，然后将这些内容直接传送到主存，不需要<code>CPU</code>的干涉<code>(图6-12b)</code>。设备可以自己执行读或者写总线事务而不需要<code>CPU</code>干涉的过程，称为直接内存访问<code>(Direct Memory Access, DMA)</code>。这种数据传送称为DMA传送<code>(DMA transfer)</code>。</p>
<p>在<code>DMA</code>传送完成，磁盘扇区的内容被安全地存储在主存中以后，磁盘控制器通过给<code>CPU</code>发送一个中断信号来通知<code>CPU(图6-12c)</code>。基本思想是中断会发信号到<code>CPU</code>芯片的一个外部引脚上。这会导致<code>CPU</code>暂停它当前正在做的工作，跳转到一个操作系统例程。这个程序会记录下<code>I/O</code>已经完成，然后将控制返回到<code>CPU</code>被中断的地方。</p>
<h2 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h2><p>固态硬盘<code>(Solid State Disk, SSD)</code>是一种基于闪存的存储技术<code>(参见6.1.1节)</code>，在某些情况下是传统旋转磁盘的极有吸引力的替代产品。图<code>6-13</code>展示了它的基本思想。<code>SSD</code>封装插到<code>I/O</code>总线上标准硬盘插槽<code>(通常是USB或SATA)</code>中，行为就和其他硬盘一样，处理来自<code>CPU</code>的读写逻辑磁盘块的请求。一个<code>SSD</code>封装由一个或多个闪存芯片和闪存翻译层<code>(flash translation layer)</code>组成，闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译层是一个硬件<code>/</code>固件设备，扮演与磁盘控制器相同的角色，将对逻辑块的请求翻译成对底层物理设备的访问。</p>
<p><img src="/posts/mem-hier1/6-13.png"></p>
<p>图<code>6-14</code>展示了典型<code>SSD</code>的性能特性。注意，读<code>SSD</code>比写要快。随机读和写的性能差别是由底层闪存基本属性决定的。如图<code>6-13</code>所示，一个闪存由<code>B</code>个块的序列组成，每个块由<code>P</code>页组成。通常，页的大小是<code>512Byte~4KB</code>，块是由<code>32~128</code>页组成的，块的大小为<code>16KB~512KB</code>。数据是以页为单位读写的，只有在一页所属的块整个被擦除之后，才能写这一页<code>(通常是指该块中的所有位都被设置为1)</code>。不过，一旦一个块被擦除了，块中每一个页都可以不需要再进行擦除就写一次。在大约进行100000次重复写之后，块就会磨损坏。一旦一个块磨损坏之后，就不能再使用了。</p>
<p><img src="/posts/mem-hier1/6-14.png"></p>
<p>随机写很慢，有两个原因。首先，擦除块需要相对较长的时间，1ms级的，比访问页所需时间要高一个数量级。其次，如果写操作试图修改一个包含已经有数据<code>(也就是不是全为1)</code>的页<code>p</code>，那么这个块中所有带有用数据的页都必须被复制到一个新<code>(擦除过的)</code>块，然后才能进行对页<code>p</code>的写。制造商已经在闪存翻译层中实现了复杂的逻辑，试图抵消擦写块的高昂代价，最小化内部写的次数，但是随机写的性能不太可能和读一样好。</p>
<p>比起旋转磁盘，<code>SSD</code>有很多优点。它们由半导体存储器构成，没有移动的部件，因而随机访问时间比旋转磁盘要快，能耗更低，同时也更结实。不过，也有一些缺点。首先，因为反复写之后，闪存块会磨损，所以<code>SSD</code>也容易磨损。闪存翻译层中的平均磨损<code>(wear leveling)</code>逻辑试图通过将擦除平均分布在所有的块上来最大化每个块的寿命。实际上，平均磨损逻辑处理得非常好，要很多年<code>SSD</code>才会磨损坏<code>(参考练习题6.5)</code>。其次，<code>SSD</code>每字节比旋转磁盘贵大约30倍，因此常用的存储容量比旋转磁盘小100倍。不过，随着<code>SSD</code>变得越来越受欢迎，它的价格下降得非常快，而两者的价格差也在减少。</p>
<p>在便携音乐设备中，<code>SSD</code>已经完全的取代了旋转磁盘，在笔记本电脑中也越来越多地作为硬盘的替代品，甚至在台式机和服务器中也开始出现了。虽然旋转磁盘还会继续存在，但是显然，<code>SSD</code>是一项重要的替代选择。</p>
<h2 id="存储技术趋势"><a href="#存储技术趋势" class="headerlink" title="存储技术趋势"></a>存储技术趋势</h2><p>从我们对存储技术的讨论中，可以总结出几个很重要的思想：</p>
<ul>
<li>不同的存储技术有不同的价格和性能折中</li>
</ul>
<p><code>SRAM</code>比<code>DRAM</code>快一点，而<code>DRAM</code>比磁盘要快很多。另一方面，快速存储总是比慢速存储要贵的。<code>SRAM</code>每字节的造价比<code>DRAM</code>高，<code>DRAM</code>的造价又比磁盘高得多。<code>SSD</code>位于<code>DRAM</code>和旋转磁盘之间。</p>
<ul>
<li>不同存储技术的价格和性能属性以截然不同的速率变化着</li>
</ul>
<p>图<code>6-15</code>总结了从1985年以来的存储技术的价格和性能属性，那时第一台<code>PC</code>刚刚发明不久。这些数字是从以前的商业杂志中和<code>Web</code>上挑选出来的。虽然它们是从非正式的调查中得到的，但是这些数字还是能揭示出一些有趣的趋势。</p>
<p>自从1985年以来，<code>SRAM</code>技术的成本和性能基本上是以相同的速度改善的。访问时间和每兆字节成本下降了大约100倍<code>(图6-15a)</code>。不过，<code>DRAM</code>和磁盘的变化趋势更大，而且更不一致。<code>DRAM</code>每兆字节成本下降了44000倍<code>(超过了四个数量级！)</code>，而<code>DRAM</code>的访问时间只下降了大约10倍<code>(图6-15b)</code>。磁盘技术有和<code>DRAM</code>相同的趋势，甚至变化更大。从1985年以来，磁盘存储的每兆字节成本暴跌了3000000倍<code>(超过了六个数量级！)</code>，但是访问时间提高得很慢，只有25倍左右<code>(图6-15c)</code>。这些惊人的长期趋势突出了内存和磁盘技术的一个基本事实：增加密度<code>(从而降低成本)</code>比降低访问时间容易得多。</p>
<ul>
<li><code>DRAM</code>和磁盘的性能滞后于<code>CPU</code>的性能</li>
</ul>
<p>正如我们在图<code>6-15d</code>中看到的那样，从1985年到2010年，<code>CPU</code>周期时间提高了500倍。如果我们看有效周期时间<code>(effective cycle time)</code>——我们定义为一个单独的<code>CPU(处理器)</code>的周期时间除以它的处理器核数——那么从1985年到2010年的提高还要大一些，为2000倍。<code>CPU</code>性能曲线在2003年附近的突然变化反映的是多核处理器的出现<code>(参见6.2节的旁注)</code>，在这个分割点之后，单个核的周期时间实际上增加了一点点，然后又开始下降，不过比以前的速度要慢一些。</p>
<p><img src="/posts/mem-hier1/6-15.png"></p>
<p>注意，虽然<code>SRAM</code>的性能滞后于<code>CPU</code>的性能，但还是在保持增长。不过，<code>DRAM</code>和磁盘性能与<code>CPU</code>性能之间的差距实际上是在加大的。直到2003年左右多核处理器的出现，这个性能差距都是延迟的函数，<code>DRAM</code>和磁盘的访问时间比单个处理器的周期时间提高得更慢。不过，随着多核的出现，这个性能越来越成为了吞吐量的函数，多个处理器核并发地向<code>DRAM</code>和磁盘发请求。图<code>6-16</code>清楚地表明了各种趋势，以半对数为比例<code>(semi-log scale)</code>，画出了图<code>6-15</code>中的访问时间和周期时间。</p>
<p><img src="/posts/mem-hier1/6-16.png"></p>
<p>正如我们将在<code>6.4</code>节中看到的那样，现代计算机频繁地使用基于<code>SRAM</code>的高速缓存，试图弥补处理器与内存之间的差距。这种方法行之有效是因为应用程序的一个称为局部性<code>(locality)</code>的基本属性，接下来我们就讨论这个问题。</p>
<h1 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h1><p>一个编写良好的计算机程序常常具有良好的局部性<code>(locality)</code>。也就是，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为局部性原理<code>(principle of locality)</code>，是一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响。</p>
<p>局部性通常有两种不同的形式：时间局部性<code>(temporal locality)</code>和空间局部性<code>(spatial locality)</code>。在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用。在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。</p>
<p>程序员应该理解局部性原理，因为一般而言，有良好局部性的程序比局部性差的程序运行得更快。现代计算机系统的各个层次，从硬件到操作系统、再到应用程序，它们的设计都利用了局部性。在硬件层，局部性原理允许计算机设计者通过引入称为高速缓存存储器的小而快速的存储器来保存最近被引用的指令和数据项，从而提高对主存的访问速度。在操作系统级，局部性原理允许系统使用主存作为虚拟地址空间最近被引用块的高速缓存。类似地，操作系统用主存来缓存磁盘文件系统中最近被使用的磁盘块。局部性原理在应用程序的设计中也扮演着重要的角色。例如，<code>Web</code>浏览器将最近被引用的文档放在本地磁盘上，利用的就是时间局部性。大容量的<code>Web</code>服务器将最近被请求的文档放在前端磁盘高速缓存中，这些缓存能满足对这些文档的请求，而不需要服务器的任何干预。</p>
<h2 id="对程序数据引用的局部性"><a href="#对程序数据引用的局部性" class="headerlink" title="对程序数据引用的局部性"></a>对程序数据引用的局部性</h2><p>考虑图<code>6-17a</code>中的简单函数，它对一个向量的元素求和。这个程序有良好的局部性吗？要回答这个问题，我们来看看每个变量的引用模式。在这个例子中，变量<code>sum</code>在每次循环迭代中被引用一次，因此，对于<code>sum</code>来说，有好的时间局部性。另一方面，因为<code>sum</code>是标量，对于<code>sum</code>来说，没有空间局部性。</p>
<p><img src="/posts/mem-hier1/6-17.png"></p>
<p>正如我们在图<code>6-17b</code>中看到的，向量<code>v</code>的元素是被顺序读取的，一个接一个，按照它们存储在内存中的顺序<code>(为了方便，我们假设数组是从地址0开始的)</code>。因此，对于变量<code>v</code>，函数有很好的空间局部性，但是时间局部性很差，因为每个向量元素只被访问一次。因为对于循环体中的每个变量，这个函数要么有好的空间局部性，要么有好的时间局部性，所以我们可以断定<code>sumvec</code>函数有良好的局部性。</p>
<p>我们说像<code>sumvec</code>这样顺序访问一个向量每个元素的函数，具有步长为1的引用模式<code>(sride-1 reference pattern)(相对于元素的大小)</code>。有时我们称步长为1的引用模式为顺序引用模式<code>(sequential reference pattern)</code>。一个连续向量中，每隔<code>k</code>个元素进行访问，就称为步长为<code>k</code>的引用模式<code>(stride-k reference pattern)</code>。步长为1的引用模式是程序中空间局部性常见和重要的来源。一般而言，随着步长的增加，空间局部性下降。</p>
<p>对于引用多维数组的程序来说，步长也是一个很重要的问题。例如，考虑图<code>6-18a</code>中的函数 <code>sumarrayrows</code>，它对一个二维数组的元素求和。双重嵌套循环按照行优先顺序<code>(row-major order)</code>读数组的元素。也就是，内层循环读第一行的元素，然后读第二行，依此类推。函数 <code>sumarrayrows</code>具有良好的空间局部性，因为它按照数组被存储的行优先顺序来访问这个数组<code>(图6-18b)</code>。其结果是得到一个很好的步长为1的引用模式，具有良好的空间局部性。</p>
<p><img src="/posts/mem-hier1/6-18.png"></p>
<p>一些看上去很小的对程序的改动能够对它的局部性有很大的影响。例如，图<code>6-19a</code>中的函数 <code>sumarraycols</code>计算的结果和图<code>6-18a</code>中函数<code>sumarrayrows</code>的一样。唯一的区别是我们交换了<code>i</code>和<code>j</code>的循环。这样交换循环对它的局部性有何影响？函数<code>sumarraycols</code>的空间局部性很差，因为它按照列顺序来扫描数组，而不是按照行顺序。因为C数组在内存中是按照行顺序来存放的，结果就得到步长为<code>N</code>的引用模式，如图<code>6-19b</code>所示。</p>
<p><img src="/posts/mem-hier1/6-19.png"></p>
<h2 id="取指令的局部性"><a href="#取指令的局部性" class="headerlink" title="取指令的局部性"></a>取指令的局部性</h2><p>因为程序指令是存放在内存中的，<code>CPU</code>必须取出<code>(读出)</code>这些指令，所以我们也能够评价一个程序关于取指令的局部性。例如，图<code>6-17</code>中<code>for</code>循环体里的指令是按照连续的内存顺序执行的，因此循环有良好的空间局部性。因为循环体会被执行多次，所以它也有很好的时间局部性。</p>
<p>代码区别于程序数据的一个重要属性是在运行时它是不能被修改的。当程序正在执行时，<code>CPU</code>只从内存中读出它的指令。<code>CPU</code>很少会重写或修改这些指令。</p>
<h2 id="局部性小结"><a href="#局部性小结" class="headerlink" title="局部性小结"></a>局部性小结</h2><p>在这一节中，我们介绍了局部性的基本思想，还给出了量化评价程序中局部性的一些简单原则：</p>
<ul>
<li><p>重复引用相同变量的程序有良好的时间局部性</p>
</li>
<li><p>对于具有步长为<code>k</code>的引用模式的程序，步长越小，空间局部性越好。具有步长为1的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局部性会很差</p>
</li>
<li><p>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好</p>
</li>
</ul>
<p>在本章后面，在我们学习了高速缓存存储器以及它们是如何工作的之后，我们会介绍如何用高速缓存命中率和不命中率来量化局部性的概念。你还会弄明白为什么有良好局部性的程序通常比局部性差的程序运行得更快。尽管如此，了解如何看一眼源代码就能获得对程序中局部性的高层次的认识，是程序员要掌握的一项有用而且重要的技能。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://csapp.cs.cmu.edu/"><code>Computer Systems: A Programmer&#39;s Perspective, 3/E</code></a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CSAPP/" rel="tag"><i class="fa fa-tag"></i> CSAPP</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/htb-pressed/" rel="prev" title="HTB Pressed">
                  <i class="fa fa-chevron-left"></i> HTB Pressed
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/mem-hier2/" rel="next" title="存储器层次结构(二)">
                  存储器层次结构(二) <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lu0k</span>
</div>

    </div>
  </footer>

  
  <script size="250" alpha="0.5" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  





</body>
</html>
