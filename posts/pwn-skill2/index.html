<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-lu0k.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-lu0k.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-lu0k.png">
  <link rel="mask-icon" href="/images/lu0k.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lu0k.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="SSP LeakStack Smashing Protector(SSP)是一个著名的缓冲区溢出漏洞缓解措施，其首次出现是1998年作为StackGuard被引入GCC，后来发展成ProPolice，由RedHat实现了-fstack-protector和-fstack-protector-all编译选项。当一个函数检测到栈上的Canary被破坏时，就会转到__stack_chk_fail()函数">
<meta property="og:type" content="article">
<meta property="og:title" content="PWN利用技巧(下)">
<meta property="og:url" content="https://lu0k.github.io/posts/pwn-skill2/index.html">
<meta property="og:site_name" content="Lu0k">
<meta property="og:description" content="SSP LeakStack Smashing Protector(SSP)是一个著名的缓冲区溢出漏洞缓解措施，其首次出现是1998年作为StackGuard被引入GCC，后来发展成ProPolice，由RedHat实现了-fstack-protector和-fstack-protector-all编译选项。当一个函数检测到栈上的Canary被破坏时，就会转到__stack_chk_fail()函数">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-12-05T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-08T10:17:19.130Z">
<meta property="article:author" content="Lu0k">
<meta property="article:tag" content="Pwn">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lu0k.github.io/posts/pwn-skill2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lu0k.github.io/posts/pwn-skill2/","path":"posts/pwn-skill2/","title":"PWN利用技巧(下)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>PWN利用技巧(下) | Lu0k</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Lu0k</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Lu0k's Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SSP-Leak"><span class="nav-number">1.</span> <span class="nav-text">SSP Leak</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SSP"><span class="nav-number">1.1.</span> <span class="nav-text">SSP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stack-chk-fali"><span class="nav-number">1.2.</span> <span class="nav-text">__stack_chk_fali()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#environ%E6%B3%84%E9%9C%B2"><span class="nav-number">2.</span> <span class="nav-text">environ泄露</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IO-FILE%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">_IO_FILE结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FILE%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">3.1.</span> <span class="nav-text">FILE结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FSOP"><span class="nav-number">3.2.</span> <span class="nav-text">FSOP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%A9%E7%94%A8vsyscall"><span class="nav-number">4.</span> <span class="nav-text">利用vsyscall</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vsyscall%E5%92%8CvDSO"><span class="nav-number">4.1.</span> <span class="nav-text">vsyscall和vDSO</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">5.</span> <span class="nav-text">Reference</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lu0k"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Lu0k</p>
  <div class="site-description" itemprop="description">谦虚学习!</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">145</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lu0k" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lu0k" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Lu0kMe" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Lu0kMe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lu0k.github.io/posts/pwn-skill2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Lu0k">
      <meta itemprop="description" content="谦虚学习!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lu0k">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          PWN利用技巧(下)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-06 00:00:00" itemprop="dateCreated datePublished" datetime="2021-12-06T00:00:00+08:00">2021-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Read-Notes/" itemprop="url" rel="index"><span itemprop="name">Read Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="SSP-Leak"><a href="#SSP-Leak" class="headerlink" title="SSP Leak"></a>SSP Leak</h1><p><code>Stack Smashing Protector(SSP)</code>是一个著名的缓冲区溢出漏洞缓解措施，其首次出现是1998年作为<code>StackGuard</code>被引入<code>GCC</code>，后来发展成<code>ProPolice</code>，由<code>RedHat</code>实现了<code>-fstack-protector</code>和<code>-fstack-protector-all</code>编译选项。当一个函数检测到栈上的<code>Canary</code>被破坏时，就会转到<code>__stack_chk_fail()</code>函数终止程序运行并抛出错误信息。</p>
<span id="more"></span>

<p>该错误信息包含了<code>argv[0]</code>指向的字符串，如果能够控制<code>argv[0]</code>，那么将可能造成信息泄露，这一技术被称为<code>SSP Leak</code>。具体细节可查看文章<a target="_blank" rel="noopener" href="http://site.pi3.com.pl/papers/ASSP.pdf">Adventure with Stack Smashing Protector (SSP)</a>。</p>
<h2 id="SSP"><a href="#SSP" class="headerlink" title="SSP"></a>SSP</h2><p>一个简单的示例程序如下，默认情况下<code>argv[0]</code>是指向程序路径及名称的指针，当检查到栈溢出时，在标准错误中打印出了这个字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argv[0]: %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc 1.c -o a.out</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python2 -c <span class="string">&#x27;print &quot;A&quot;*50&#x27;</span> | ./a.out</span> </span><br><span class="line">argv[0]: ./a.out</span><br><span class="line">*** stack smashing detected ***: ./a.out terminated</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>

<p>修改示例程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argv[0]: %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    argv[<span class="number">0</span>] = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc 1.c -o b.out</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python2 -c <span class="string">&#x27;print &quot;A&quot;*50&#x27;</span> | ./b.out</span></span><br><span class="line">argv[0]: ./b.out</span><br><span class="line">*** stack smashing detected ***: Hello World! terminated</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>

<p>查看汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">gef➤  disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001189 &lt;+0&gt;:	endbr64 </span><br><span class="line">   0x000000000000118d &lt;+4&gt;:	push   rbp</span><br><span class="line">   0x000000000000118e &lt;+5&gt;:	mov    rbp,rsp</span><br><span class="line">   0x0000000000001191 &lt;+8&gt;:	sub    rsp,0x30</span><br><span class="line">   0x0000000000001195 &lt;+12&gt;:	mov    DWORD PTR [rbp-0x24],edi</span><br><span class="line">   0x0000000000001198 &lt;+15&gt;:	mov    QWORD PTR [rbp-0x30],rsi</span><br><span class="line">   0x000000000000119c &lt;+19&gt;:	mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00000000000011a5 &lt;+28&gt;:	mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">   0x00000000000011a9 &lt;+32&gt;:	xor    eax,eax</span><br><span class="line">   0x00000000000011ab &lt;+34&gt;:	mov    rax,QWORD PTR [rbp-0x30]</span><br><span class="line">   0x00000000000011af &lt;+38&gt;:	mov    rax,QWORD PTR [rax]</span><br><span class="line">   0x00000000000011b2 &lt;+41&gt;:	mov    rsi,rax</span><br><span class="line">   0x00000000000011b5 &lt;+44&gt;:	lea    rdi,[rip+0xe48]</span><br><span class="line">   0x00000000000011bc &lt;+51&gt;:	mov    eax,0x0</span><br><span class="line">   0x00000000000011c1 &lt;+56&gt;:	call   0x1080 &lt;printf@plt&gt;</span><br><span class="line">   0x00000000000011c6 &lt;+61&gt;:	lea    rax,[rbp-0x12]</span><br><span class="line">   0x00000000000011ca &lt;+65&gt;:	mov    rsi,rax</span><br><span class="line">   0x00000000000011cd &lt;+68&gt;:	lea    rdi,[rip+0xe3d]</span><br><span class="line">   0x00000000000011d4 &lt;+75&gt;:	mov    eax,0x0</span><br><span class="line">   0x00000000000011d9 &lt;+80&gt;:	call   0x1090 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x00000000000011de &lt;+85&gt;:	mov    rax,QWORD PTR [rbp-0x30]</span><br><span class="line">   0x00000000000011e2 &lt;+89&gt;:	lea    rdx,[rip+0xe2b]</span><br><span class="line">   0x00000000000011e9 &lt;+96&gt;:	mov    QWORD PTR [rax],rdx</span><br><span class="line">   0x00000000000011ec &lt;+99&gt;:	nop</span><br><span class="line">   0x00000000000011ed &lt;+100&gt;:	mov    rax,QWORD PTR [rbp-0x8]</span><br><span class="line">   0x00000000000011f1 &lt;+104&gt;:	xor    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00000000000011fa &lt;+113&gt;:	je     0x1201 &lt;main+120&gt;</span><br><span class="line">   0x00000000000011fc &lt;+115&gt;:	call   0x1070 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000000000001201 &lt;+120&gt;:	leave  </span><br><span class="line">   0x0000000000001202 &lt;+121&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>程序先从栈<code>([rbp-0x30])</code>上取出<code>Canary</code>，将其与初始<code>Canary(fs:0x28)</code>相比较，如果两者不相同，说明发生了栈溢出。此时程序不能正常返回，而是调用<code>__stack_chk_fail()</code>函数，打印出<code>argv[0]</code>指向的字符串。</p>
<p>由于栈是从低地址向高地址增长的，而缓冲区却是从低地址到高地址增长的，所以<code>argv</code>数组位于栈中高地址的位置，只要读入字符串足够长，就可以覆盖到<code>argv[0]</code>。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python2 -c <span class="string">&#x27;print &quot;A&quot;*264&#x27;</span> | ./a.out</span></span><br><span class="line">argv[0]: ./a.out</span><br><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line">Aborted (core dumped)</span><br><span class="line"><span class="meta">$</span><span class="bash"> python2 -c <span class="string">&#x27;print &quot;A&quot;*265&#x27;</span> | ./a.out</span></span><br><span class="line">argv[0]: ./a.out</span><br><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line">Aborted (core dumped)</span><br><span class="line"><span class="meta">$</span><span class="bash"> python2 -c <span class="string">&#x27;print &quot;A&quot;*266&#x27;</span> | ./a.out</span></span><br><span class="line">argv[0]: ./a.out</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<h2 id="stack-chk-fali"><a href="#stack-chk-fali" class="headerlink" title="__stack_chk_fali()"></a>__stack_chk_fali()</h2><p>在<code>glibc-2.23</code>中，<code>__stack_chk_fail()</code>函数调用<code>__fortify_fail()</code>函数，再由<code>__fortify_fail()</code>函数，将标准错误和<code>argv[0]</code>打印出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// debug/stack_chk_fail.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// debug/fortify_fail.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn)) internal_function</span><br><span class="line">__fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">		    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查<code>__libc_message()</code>函数，环境变量<code>LIBC_FATAL_STDERR_</code>被函数<code>__libc_secure_getenv()</code>所读取，如果该变量没有被设置或者被设置为空，即<code>NULL</code>，那么标准错误<code>stderr</code>会被重定向到<code>_PATH_TTY</code>，该值通常是<code>/dev/tty</code>，因此会直接在当前终端打印出来，而不是传到<code>stderr</code>。所以，如果目标是远程服务器，就需要考虑将<code>LIBC_FATAL_STDERR_</code>设置为一个非<code>NULL</code>的值，从而通过<code>stderr</code>得到泄露信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysdeps/posix/libc_fatal.c</span></span><br><span class="line"><span class="comment">/* Abort with an error message.  */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_message (<span class="keyword">int</span> do_abort, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">  va_start (ap, fmt);</span><br><span class="line">......</span><br><span class="line">  <span class="comment">/* Open a descriptor for /dev/tty unless the user explicitly</span></span><br><span class="line"><span class="comment">     requests errors on standard error.  */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *on_2 = __libc_secure_getenv (<span class="string">&quot;LIBC_FATAL_STDERR_&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (on_2 == <span class="literal">NULL</span> || *on_2 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    fd = open_not_cancel_2 (_PATH_TTY, O_RDWR | O_NOCTTY | O_NDELAY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    fd = STDERR_FILENO;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><code>glibc-2.25</code>启用了一个新的函数<code>__fortify_fail_abort()</code>，试图对该泄露问题进行修复。函数的第一个参数为<code>false</code>时，将不再进行栈回溯，而是直接打印出字符串<code>&quot;&lt;unknown&gt;&quot;</code>，那么也就无法输出<code>argv[0]</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// debug/stack_chk_fail.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail_abort (<span class="literal">false</span>, <span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// debug/fortify_fail.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__fortify_fail_abort (<span class="built_in">_Bool</span> need_backtrace, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  Don&#x27;t pass down</span></span><br><span class="line"><span class="comment">     __libc_argv[0] if we aren&#x27;t doing backtrace since __libc_argv[0]</span></span><br><span class="line"><span class="comment">     may point to the corrupted stack.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (need_backtrace ? (do_abort | do_backtrace) : do_abort,</span><br><span class="line">                    <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg,</span><br><span class="line">                    (need_backtrace &amp;&amp; __libc_argv[<span class="number">0</span>] != <span class="literal">NULL</span></span><br><span class="line">                     ? __libc_argv[<span class="number">0</span>] : <span class="string">&quot;&lt;unknown&gt;&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail_abort (<span class="literal">true</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python2 -c <span class="string">&#x27;print &quot;A&quot;*50&#x27;</span> | ./b.out</span></span><br><span class="line">argv[0]: ./b.out</span><br><span class="line">*** stack smashing detected ***: &lt;unknown&gt; terminated</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>

<h1 id="environ泄露"><a href="#environ泄露" class="headerlink" title="environ泄露"></a>environ泄露</h1><p><code>glibc</code>中定义的全局变量<code>environ</code>指向内存中的环境变量表，更具体地，该表就位于栈上，因此通过泄露<code>environ</code>指针的地址，即可获得栈地址。如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">gef➤  vmmap libc</span><br><span class="line">[ Legend:  Code | Heap | Stack ]</span><br><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x00007ffff7dc6000 0x00007ffff7deb000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">0x00007ffff7deb000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">0x00007ffff7f63000 0x00007ffff7fad000 0x000000000019d000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">0x00007ffff7fad000 0x00007ffff7fae000 0x00000000001e7000 --- /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">0x00007ffff7fae000 0x00007ffff7fb1000 0x00000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">0x00007ffff7fb1000 0x00007ffff7fb4000 0x00000000001ea000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">gef➤  vmmap stack</span><br><span class="line">[ Legend:  Code | Heap | Stack ]</span><br><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]</span><br><span class="line">gef➤  shell nm -D /lib/x86_64-linux-gnu/libc-2.31.so | grep environ</span><br><span class="line">00000000001ef2e0 B __environ</span><br><span class="line">00000000001ef2e0 V _environ</span><br><span class="line">00000000001ef2e0 V environ</span><br><span class="line">gef➤  x/gx 0x00007ffff7dc6000 + 0x1ef2e0</span><br><span class="line">0x7ffff7fb52e0 &lt;environ&gt;:	0x00007fffffffe038</span><br><span class="line">gef➤  x/4gx 0x00007fffffffe038</span><br><span class="line">0x7fffffffe038:	0x00007fffffffe38a	0x00007fffffffe39a</span><br><span class="line">0x7fffffffe048:	0x00007fffffffe3e8	0x00007fffffffe3fb</span><br><span class="line">gef➤  x/4s 0x00007fffffffe38a</span><br><span class="line">0x7fffffffe38a:	&quot;SHELL=/bin/bash&quot;</span><br><span class="line">0x7fffffffe39a:	&quot;SESSION_MANAGER=local/luck:@/tmp/.ICE-unix/2222,unix/luck:/tmp/.ICE-unix/2222&quot;</span><br><span class="line">0x7fffffffe3e8:	&quot;QT_ACCESSIBILITY=1&quot;</span><br><span class="line">0x7fffffffe3fb:	&quot;COLORTERM=truecolor&quot;</span><br></pre></td></tr></table></figure>

<h1 id="IO-FILE结构"><a href="#IO-FILE结构" class="headerlink" title="_IO_FILE结构"></a>_IO_FILE结构</h1><p><code>FILE</code>结构的利用是一种通用的控制流劫持技术。攻击者可以覆盖堆上的<code>FILE</code>指针使其指向一个伪造的结构体，并通过结构中一个名为<code>vtable</code>的指针，来执行任意代码。</p>
<h2 id="FILE结构体"><a href="#FILE结构体" class="headerlink" title="FILE结构体"></a>FILE结构体</h2><p><code>FILE</code>结构被一系列流操作函数<code>(fopen()、fread()、fclose()等)</code>所使用，大多数的<code>FILE</code>结构体保存在堆上<code>(stdin、stdout、stderr除外, 位于libc数据段)</code>，其指针动态创建并由<code>fopen()</code>函数返回。在<code>glibc-2.23</code>版本中，这个结构体是<code>_IO_FILE_plus</code>，包含了一个<code>_IO_FILE</code>结构体和一个指向<code>_IO_dump_t</code>结构体的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* We always allocate an extra word following an _IO_FILE.</span></span><br><span class="line"><span class="comment">   This contains a pointer to the function jump table used.</span></span><br><span class="line"><span class="comment">   This is for compatibility with C++ streambuf; the word can</span></span><br><span class="line"><span class="comment">   be used to smash to a pointer to a virtual function table. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span>;</span></span><br></pre></td></tr></table></figure>

<p><code>vtable</code>指向的函数跳转表其实是一种兼容<code>C++</code>虚函数的实现。当程序对某个流进行操作时，会调用该流对应的跳转表中的某个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>进程中的<code>FILE</code>结构通过<code>_chain</code>域构成一个链表，链表头部为<code>_IO_list_all</code>全局变量，默认情况下依次链接了<code>stderr</code>、<code>stdout</code>和<code>stdin</code>三个文件流，并将新创建的流插入到头部。另外，<code>_IO_wide_data</code>结构也是需要的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Extra data for wide character streams.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_end;		<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_base;	<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_backup_base;	<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">				   backup area */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_end;	<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="keyword">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p><code>FSOP(File Stream Oriented Programming)</code>是一种劫持<code>_IO_list_all(全局变量)</code>来伪造链表的利用技术，通过调用<code>_IO_flush_all_lockp()</code>函数触发。该函数会在下面三种情况下被调用：</p>
<ul>
<li>当<code>glibc</code>检测到内存错误从而执行<code>abort</code>流程时</li>
<li>执行<code>exit</code>函数时</li>
<li>当<code>main</code>函数返回时</li>
</ul>
<p>当<code>glibc</code>检测到内存错误时，会产生下面的函数调用路径：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc_printerr-&gt;__libc_message-&gt;__GI_abort-&gt;_IO_flush_all_lockp-&gt;_IO_OVERFLOW</span><br></pre></td></tr></table></figure>

<p><code>FSOP</code>通过伪造<code>_IO_dump_t</code>中的<code>__overflow</code>为<code>system()</code>函数地址，最终在<code>_IO_OVERFLOW(fp, EOF)</code>函数中执行<code>system(&#39;/bin/sh&#39;)</code>并获得<code>shell</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> last_stamp;</span><br><span class="line">......</span><br><span class="line">  last_stamp = _IO_list_all_stamp;</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;		<span class="comment">//覆盖为伪造的链表</span></span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_flockfile (fp);</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)		<span class="comment">//fp指向伪造的vtable, 触发虚函数</span></span><br><span class="line">	result = EOF;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">if</span> (last_stamp != _IO_list_all_stamp)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Something was added to the list.  Start all over again.  */</span></span><br><span class="line">	  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">	  last_stamp = _IO_list_all_stamp;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp = fp-&gt;_chain;		<span class="comment">// 指向下一个_IO_FILE对象</span></span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一条<code>FSOP</code>路径是在关闭流的时候，在<code>_IO_FINISH(fp)</code>的执行过程中最终会调用伪造的<code>system(&#39;/bin/sh&#39;)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_FINISH(FP) JUMP1 (__finish, FP, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line">......</span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);			<span class="comment">// fp指向伪造的vtable, 触发虚函数</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="利用vsyscall"><a href="#利用vsyscall" class="headerlink" title="利用vsyscall"></a>利用vsyscall</h1><p>在一个开启<code>ASLR</code>的系统上运行一个<code>PIE</code>的二进制文件，可以很大程度上进行地址随机化，增加漏洞利用的难度。然而在内存空间中，<code>vsyacall</code>页由于历史的原因并没有随机化，虽然大部分指令已经被移除，并替换为一些特殊的陷入<code>(trap)</code>指令，但仍然可能成为攻击者的突破口。</p>
<h2 id="vsyscall和vDSO"><a href="#vsyscall和vDSO" class="headerlink" title="vsyscall和vDSO"></a>vsyscall和vDSO</h2><p>执行系统调用是一项比较消耗资源的行为，因为处理器需要终端当前进程，做用户态与内核态上下文的切换。当遇到一些调用很频繁且不需要任何特权的系统调用<code>(例如gettimeofday)</code>时，系统的负载就更加明显。于是，开发者设计了两种用于加速特定系统调用执行的机制：<code>vsyscall</code>和<code>vDSO</code>。</p>
<p><code>vsyscall(virtual system call)</code>是最早引入的技术，其将内核中的一些变量和特定系统调用的实现映射到用户态，程序在调用时就不需要再切入内核，从而加快执行速度，降低负载。但是<code>vsyscall</code>采用固定地址进行分配，在每个进程中都位于相同位置，这就可能导致安全问题。攻击者在使用<code>vsyscall</code>中的<code>gadgets</code>时不需要考虑内存地址随机化，降低了攻击的难度。虽然Linux内核从3.3版本开始，<code>vsyscall</code>使用特殊的陷入指令替换掉了原来的固定指令，但是新的陷入机制在内核态模拟虚拟系统调用，反而产生了更大的负载。</p>
<p><code>vsyscall</code>入口的汇编代码如下所示，包含3个特定的系统调用<code>gettimeofday</code>、<code>time</code>和<code>getcpu</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/linkage.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;asm/irq_vectors.h&gt;</span><br><span class="line">#include &lt;asm/page_types.h&gt;</span><br><span class="line">#include &lt;asm/unistd_64.h&gt;</span><br><span class="line"></span><br><span class="line">__PAGE_ALIGNED_DATA</span><br><span class="line">	.globl __vsyscall_page</span><br><span class="line">	.balign PAGE_SIZE, 0xcc</span><br><span class="line">	.type __vsyscall_page, @object</span><br><span class="line">__vsyscall_page:</span><br><span class="line"></span><br><span class="line">	mov $__NR_gettimeofday, %rax</span><br><span class="line">	syscall</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	.balign 1024, 0xcc</span><br><span class="line">	mov $__NR_time, %rax</span><br><span class="line">	syscall</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	.balign 1024, 0xcc</span><br><span class="line">	mov $__NR_getcpu, %rax</span><br><span class="line">	syscall</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	.balign 4096, 0xcc</span><br><span class="line">	.size __vsyscall_page, 4096</span><br></pre></td></tr></table></figure>

<p>在程序内存中，<code>vsyscall</code>没有进行内存地址随机化，而是从固定地址<code>0xffffffffff600000</code>开始，三个系统调用以<code>0x400</code>字节对齐，其余内存都以<code>int3</code>指令填充。内存权限为可读可执行，但不可写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gef➤  vmmap vsyscall</span><br><span class="line">[ Legend:  Code | Heap | Stack ]</span><br><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]</span><br><span class="line">gef➤  x/4i 0xffffffffff600000</span><br><span class="line">   0xffffffffff600000:	mov     rax,0x60</span><br><span class="line">   0xffffffffff600007:	syscall</span><br><span class="line">   0xffffffffff600009:	ret</span><br><span class="line">   0xffffffffff60000a:	int3</span><br><span class="line">gef➤  x/4i 0xffffffffff600400</span><br><span class="line">   0xffffffffff600400:	mov     rax,0xc9</span><br><span class="line">   0xffffffffff600407:	syscall</span><br><span class="line">   0xffffffffff600409:	ret</span><br><span class="line">   0xffffffffff60040a:	int3</span><br><span class="line">gef➤  x/4i 0xffffffffff600800</span><br><span class="line">   0xffffffffff600800:	mov     rax,0x135</span><br><span class="line">   0xffffffffff600807:	syscall</span><br><span class="line">   0xffffffffff600809:	ret</span><br><span class="line">   0xffffffffff60080a:	int3</span><br></pre></td></tr></table></figure>

<p><code>syscall;ret</code>指令可用于构造<code>SROP</code>的<code>sigreturn</code>，只需要在它前面再放置一个<code>pop rax</code>的<code>gadget</code>，将<code>rax</code>赋值为<code>0xf</code>。</p>
<p><code>vDSO(virtual dynamic shared object)</code>的提出就是为了替换<code>vsyscall</code>，两者最大的不同就是<code>vDSO</code>通过共享库的形式进行映射。在64位系统上，<code>vdso</code>被称为<code>linux-vdso.so.1</code>，在32位系统中则称为<code>linux-gate.so.1</code>。所有使用<code>glibc</code>的程序都自动使用了<code>vdso</code>，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ldd /bin/sh</span></span><br><span class="line">	linux-vdso.so.1 (0x00007ffe94d27000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f60145e6000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f601480c000)</span><br></pre></td></tr></table></figure>

<p>使用<code>gdb</code>转储32位的<code>vDSO</code>，可以看到<code>vDSO</code>的地址是随机化的，并且实现了几个系统调用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gef➤  vmmap dso</span><br><span class="line">[ Legend:  Code | Heap | Stack ]</span><br><span class="line">Start      End        Offset     Perm Path</span><br><span class="line">0xf7fcf000 0xf7fd1000 0x00000000 r-x [vdso]</span><br><span class="line">gef➤  dump memory vdso32.so 0xf7fcf000 0xf7fd1000</span><br><span class="line"><span class="meta">$</span><span class="bash"> objdump -T vdso32.so</span> </span><br><span class="line">vdso32.so:     file format elf32-i386</span><br><span class="line">DYNAMIC SYMBOL TABLE:</span><br><span class="line">00000540 g    DF .text	0000000d  LINUX_2.5   __kernel_vsyscall</span><br><span class="line">00000980 g    DF .text	00000327  LINUX_2.6   __vdso_gettimeofday</span><br><span class="line">00001450 g    DF .text	0000007c  LINUX_2.6   __vdso_clock_getres</span><br><span class="line">000010a0 g    DF .text	000003a9  LINUX_2.6   __vdso_clock_gettime64</span><br><span class="line">00000560 g    DF .text	00000009  LINUX_2.5   __kernel_sigreturn</span><br><span class="line">00000cb0 g    DF .text	0000003a  LINUX_2.6   __vdso_time</span><br><span class="line">00000000 g    DO *ABS*	00000000  LINUX_2.5   LINUX_2.5</span><br><span class="line">00000570 g    DF .text	00000008  LINUX_2.5   __kernel_rt_sigreturn</span><br><span class="line">00000cf0 g    DF .text	000003a7  LINUX_2.6   __vdso_clock_gettime</span><br><span class="line">00000000 g    DO *ABS*	00000000  LINUX_2.6   LINUX_2.6</span><br></pre></td></tr></table></figure>

<p>使用<code>gdb</code>转储64位的<code>vDSO</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">gef➤  vmmap vdso</span><br><span class="line">[ Legend:  Code | Heap | Stack ]</span><br><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x00007ffff7fcd000 0x00007ffff7fcf000 0x0000000000000000 r-x [vdso]</span><br><span class="line">gef➤  dump memory vdso64.so 0x00007ffff7fcd000 0x00007ffff7fcf000</span><br><span class="line"><span class="meta">$</span><span class="bash"> objdump -T vdso64.so</span></span><br><span class="line">vdso64.so:     file format elf64-x86-64</span><br><span class="line">DYNAMIC SYMBOL TABLE:</span><br><span class="line">0000000000000ac0  w   DF .text	00000000000002a5  LINUX_2.6   clock_gettime</span><br><span class="line">0000000000000870 g    DF .text	0000000000000217  LINUX_2.6   __vdso_gettimeofday</span><br><span class="line">0000000000000d70  w   DF .text	0000000000000060  LINUX_2.6   clock_getres</span><br><span class="line">0000000000000d70 g    DF .text	0000000000000060  LINUX_2.6   __vdso_clock_getres</span><br><span class="line">0000000000000870  w   DF .text	0000000000000217  LINUX_2.6   gettimeofday</span><br><span class="line">0000000000000a90 g    DF .text	0000000000000029  LINUX_2.6   __vdso_time</span><br><span class="line">0000000000000e00 g    DF .text	000000000000009c  LINUX_2.6   __vdso_sgx_enter_enclave</span><br><span class="line">0000000000000a90  w   DF .text	0000000000000029  LINUX_2.6   time</span><br><span class="line">0000000000000ac0 g    DF .text	00000000000002a5  LINUX_2.6   __vdso_clock_gettime</span><br><span class="line">0000000000000000 g    DO *ABS*	0000000000000000  LINUX_2.6   LINUX_2.6</span><br><span class="line">0000000000000dd0 g    DF .text	0000000000000025  LINUX_2.6   __vdso_getcpu</span><br><span class="line">0000000000000dd0  w   DF .text	0000000000000025  LINUX_2.6   getcpu</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>《CTF竞赛权威指南（Pwn篇）》</li>
<li><a target="_blank" rel="noopener" href="https://www.usenix.org/legacy/publications/library/proceedings/sec98/full_papers/cowan/cowan.pdf">StackGuard: Automatic Adaptive Detection and Prevention of Buffer-Overflow Attacks</a></li>
<li><a target="_blank" rel="noopener" href="http://site.pi3.com.pl/papers/ASSP.pdf">Adventure with Stack Smashing Protector (SSP)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux">Torvalds&#x2F;linux: Linux kernel source tree (github.com)</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Pwn/" rel="tag"><i class="fa fa-tag"></i> Pwn</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/pwn-skill1/" rel="prev" title="PWN利用技巧(上)">
                  <i class="fa fa-chevron-left"></i> PWN利用技巧(上)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/htb-restaurant/" rel="next" title="HTB Restaurant">
                  HTB Restaurant <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lu0k</span>
</div>

    </div>
  </footer>

  
  <script size="250" alpha="0.5" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  





</body>
</html>
