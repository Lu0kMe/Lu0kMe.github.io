<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/01/hello-world/</url>
    <content><![CDATA[<h1 id="I-am-lu0k😊"><a href="#I-am-lu0k😊" class="headerlink" title="I am lu0k😊"></a>I am lu0k😊</h1><ul>
<li>🌱 I am currently learning InfoSec.</li>
<li>📫 How to reach me: <a href="https://twitter.com/Lu0kMe">lu0k (@Lu0kMe) &#x2F; Twitter</a>]</li>
<li>😄 Pronouns: learning learning learning!</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2021/10/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><p>正则表达式可以用形式化语言理论的方式来表达。正则表达式由常量和算子组成，它们分别表示字符串的集合和在这些集合上的运算。</p>
<p>给定有限字母表Σ定义了下列常量：</p>
<ul>
<li>空集Ø表示集合Ø。</li>
<li>空串ε表示仅包含一个“不含任何字符、长度为0的字符串”的集合。</li>
<li>文本字符α∈Σ表示仅包含一个元素α的集合{α}。</li>
</ul>
<span id="more"></span>

<p>定义了下列运算：</p>
<ul>
<li>串接RS表示集合{αβ|α∈R,β∈S}，这里的αβ表示将α和β两个字符串按顺序连接。例如{ab,c}{d,ef} &#x3D; {abd,,abef,cd,cef}。</li>
<li>选择R|S表示R与S的并集。例如{ab,c}|{ab,d,ef} &#x3D; {ab,c,d,ef}。</li>
<li>克莱尼(Kleene)星号R*表示包含ε且在字符串串接运算下闭合的R的最小超集。这是可以通过R中0或有限个字符串的串接得到的所有字符的集合。例如{ab,c}* &#x3D; {ε,ab,c,abab,abc,cab,……}。</li>
</ul>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>一个正则表达式通常被称为一个模式(pattern)，为用来描述或者匹配一系列匹配某个句法规则的字符串。大部分正则表达式的形式都有如下的结构：</p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><ul>
<li>竖线 | 代表选择(即或集)，具有最低优先级。例如：lu0k|luck可以匹配lu0k或luck。</li>
</ul>
<h2 id="数量"><a href="#数量" class="headerlink" title="数量"></a>数量</h2><p>某个字符后的数量限定符用来限定前面这个字符允许出现的个数。最常见的数量限定符包括 + 、 ? 和 * (不加数量限定则代表出现且仅出现一次)。</p>
<ul>
<li>加号 + 代表前面的字符必须至少出现一次。例如：lu0+k可以匹配lu0k、lu00k、lu000k等。</li>
<li>问号 ? 代表前面的字符最多只可以出现一次。例如：lu0?k可以匹配luk或lu0k。</li>
<li>星号 * 代表前面的字符可以不出现，也可以出现一次或多次。例如：lu0*k可以匹配luk、lu0k、lu00k、lu000k等。</li>
</ul>
<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><ul>
<li>圆括号 () 可以用来定义操作符的范围和优先度。例如：lu(0|c)k等价于lu0k|luck，(lu)?0k匹配0k和lu0k。</li>
</ul>
<p>上述的这些构造都可以自由组合，且精确的语法可能因不同的工具或程序而异。</p>
<h1 id="语法流派"><a href="#语法流派" class="headerlink" title="语法流派"></a>语法流派</h1><p>目前正则表达式主要有两大流派(flavor)：POSIX流派和PCRE流派。</p>
<h2 id="POSIX流派"><a href="#POSIX流派" class="headerlink" title="POSIX流派"></a>POSIX流派</h2><p>正则表达式的POSIX规范，分为基本型正则表达式(Basic Regular Expression，BRE)和扩展型正则表达式(Extended Regular Express，ERE)两种标准。POSIX流派的正则表达式主要用在Unix或类Unix系统中，如grep、vi、sed、egrep、awk等。</p>
<p>早期BRE与ERE的区别如下表：</p>
<table>
<thead>
<tr>
<th align="center">正则表达式特性</th>
<th align="center">BRE标准</th>
<th align="center">ERE标准</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.   ^   $   […]   [^…]</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">任意数目量词*</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">+ 和 ? 量词</td>
<td align="center">不支持(GNU扩展)</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">区间量词</td>
<td align="center">\{min,max\}</td>
<td align="center">{min,max}</td>
</tr>
<tr>
<td align="center">圆括号分组</td>
<td align="center">\{…\}</td>
<td align="center">{…}</td>
</tr>
<tr>
<td align="center">量词限定圆括号分组</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">捕获文本引用</td>
<td align="center">\1到\9</td>
<td align="center">不支持(GNU扩展)</td>
</tr>
<tr>
<td align="center">多选分支结构</td>
<td align="center">不支持(GNU扩展)</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<p>现代GNU在实现POSIX时，对两种标准均做了一定的扩展，使得GNU BRE与GNU ERE的功能特性并没有太大区别，区别在于语法层面上，一些字符要不要转义。</p>
<p>POSIX流派还有一个特殊的地方就是有自己的字符组，叫做POSIX字符组。(见附录)</p>
<h2 id="PCRE流派"><a href="#PCRE流派" class="headerlink" title="PCRE流派"></a>PCRE流派</h2><p>PCRE流派是由Perl的正则表达式衍化而来的一个正则表达式流派。</p>
<p>PCRE流派的核心是PCRE库，PCRE库由Philip Hazel用C语言编写。与POSIX相比，PCRE的语法更加强大，更加灵活。而且虽然PCRE源于Perl的正则表达式功能，但随着两者的发展，在语法上产生了一些细微的差异。PCRE被广泛使用在许多开源项目中，包括Apache，PHP，KDE、Nmap等。许多编程语言的正则表达式功能多参考借鉴了PCRE，因此PCRE的语法在这些语言中同样适用。</p>
<h1 id="表达式总结"><a href="#表达式总结" class="headerlink" title="表达式总结"></a>表达式总结</h1><p>PCRE表达式是相对而言更能代表正则表达式的表达式集合，适用于多种编程语言，且POSIX流派的表达式大多包含在PCRE表达式中，因此总结PCRE表达式。</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="center">将下一个字符标记为一个特殊字符、或一个原义子符、或一个向后引用、或一个八进制转义符</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">匹配输入字符串的开始位置。</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">匹配输入字符串的结束位置。</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">匹配前面的子表达式零次或多次。</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">匹配前面的子表达式一次或多次。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">匹配前面的子表达式零次或一次。</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="center">n是一个非负整数。匹配确定的n次。</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="center">n是一个非负整数。至少匹配n次。</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="center">m和n均为非负整数，其中n&lt;&#x3D;m。最少匹配n次且最多匹配m次。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">非贪心量化：当该字符紧跟在任何一个其他重复修饰符(*,+,?,{n},{n,},{n,m})后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">匹配除“\r”，“\n”之外的任何单个字符。</td>
</tr>
<tr>
<td align="center">(pattern)</td>
<td align="center">匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。</td>
</tr>
<tr>
<td align="center">(?:pattern)</td>
<td align="center">匹配pattern但不获取匹配的子字符串，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。</td>
</tr>
<tr>
<td align="center">(?&#x3D;pattern)</td>
<td align="center">正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td align="center">(?!pattern)</td>
<td align="center">正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td align="center">(?&lt;&#x3D;pattern)</td>
<td align="center">反向预查，与正向肯定预查类似，只是方向相反。</td>
</tr>
<tr>
<td align="center">(?&lt;!pattern)</td>
<td align="center">反向否定预查，与正向否定预查类似，只是方向相反。</td>
</tr>
<tr>
<td align="center">x|y</td>
<td align="center">没有包围在()里，其范围是整个正则表达式。</td>
</tr>
<tr>
<td align="center">[xyz]</td>
<td align="center">字符集合。匹配所包含的任意一个字符。</td>
</tr>
<tr>
<td align="center">[^xyz]</td>
<td align="center">排除型字符集合。匹配未列出的任意字符。</td>
</tr>
<tr>
<td align="center">[a-z]</td>
<td align="center">字符范围。匹配指定范围内的任意字符。</td>
</tr>
<tr>
<td align="center">[^a-z]</td>
<td align="center">排除型的字符范围。匹配任何不在指定范围内的任意字符。</td>
</tr>
<tr>
<td align="center">[:name:]</td>
<td align="center">增加命名字符类中的字符到表达式。只能用于方括号表达式。</td>
</tr>
<tr>
<td align="center">[&#x3D;elt&#x3D;]</td>
<td align="center">增加当前locale下排序等价于字符“elt”的元素。只能用于方括号表达式。</td>
</tr>
<tr>
<td align="center">[.elt.]</td>
<td align="center">增加排序元素“elt”到表达式中。只能用于方括号表达式。</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">匹配一个单词边界，也就是指单词和空格间的位置。</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="center">匹配非单词边界。</td>
</tr>
<tr>
<td align="center">\cx</td>
<td align="center">匹配由x指明的控制字符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。控制字符的值等于x的值最低5比特。</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="center">匹配一个数字字符。等价于[0-9]。注意Unicode正则表达式会匹配全角数字字符。</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="center">匹配一个非数字字符。等价于[^0-9]。</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="center">匹配一个换页符。等价于\x0c和\cL。</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">匹配一个换行符。等价于\x0a和\cJ。</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">匹配一个回车符。等价于\x0d和\cM。</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。注意Unicode正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="center">匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">匹配一个制表符。等价于\x09和\cI。</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="center">匹配一个垂直制表符。等价于\x0b和\cK。</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。注意Unicode正则表达式会匹配中文字符。</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="center">匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</td>
</tr>
<tr>
<td align="center">\xnn</td>
<td align="center">十六进制转义字符序列。匹配两个十六进制数字nn表示的字符。正则表达式中可以使用ASCII编码。</td>
</tr>
<tr>
<td align="center">\num</td>
<td align="center">向后引用一个子字符串，该子字符串与正则表达式的第num个用括号围起来的捕捉群子表达式匹配。其中num是从1开始的十进制正整数，其上限可能是9、31、99甚至无限。</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。如果n为八进制数字(0-7)，则n为一个八进制转义值。</td>
</tr>
<tr>
<td align="center">\nm</td>
<td align="center">3位八进制数字，标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字(0-7)，则\nm将匹配八进制转义值nm。</td>
</tr>
<tr>
<td align="center">\nml</td>
<td align="center">如果n为八进制数字(0-3)，且m和l均为八进制数字(0-7)，则匹配八进制转义值nml。</td>
</tr>
<tr>
<td align="center">\un</td>
<td align="center">Unicode转义字符序列。其中n是一个用四个十六进制数字表示的Unicode字符。</td>
</tr>
</tbody></table>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>在.NET、Java、Python等编程语言的正则表达式中，可以用\uXXXX表示一个Unicode字符，其中XXXX为四位16进制数字。</p>
<p>Unicode字符的三种性质：</p>
<ul>
<li><p>Unicode Property：字符属于标点、空格、字母等等。每个Unicode字符只能属于唯一Unicode Property。</p>
<ul>
<li>字符\p{L}<ul>
<li>\p{Ll}或\p{Lowercase_Letter}：小写字符(必须有大写的形式)。</li>
<li>\p{Lu}或\p{Uppercase_Letter}：大写字符(必须有小写的形式)。</li>
<li>\p{Lt}或\p{Titlecase_Letter}：全词首字母大写的字符。</li>
<li>\p{L&amp;}或\p{Cased_Letter}：存在大小写形式的字符(Ll, Lu, Lt的组合)。</li>
<li>\p{Lm}或\p{Modifier_Letter}：音标修饰字符。</li>
<li>\p{Lo}或\p{Other_Letter}：不具有大小写的字符或字形。</li>
</ul>
</li>
<li>附加符号\p{M}<ul>
<li>\p{Mn}或\p{Non_Spacing_Mark}：与其他字符结合，不额外占用空间的字符，例如日耳曼语元音变音。</li>
<li>\p{Mc}或\p{Spacing_Combining_Mark}：与其他字符结合，额外占用空间的字符，例如马拉雅拉姆文#元音字母及附标。</li>
<li>\p{Me}或\p{Enclosing_Mark}：包含其他字符的字符，例如圆圈、方块。</li>
</ul>
</li>
<li>分隔符p{Z}<ul>
<li>\p{Zs}或\p{Space_Separator}：不显示但占用空间的空白字符。</li>
<li>\p{Zl}或\p{Line_Separator}：行分隔符U+2028。</li>
<li>\p{Zp}或\p{Paragraph_Separator}：段落分隔符U+2029。</li>
</ul>
</li>
<li>符号\p{S}<ul>
<li>\p{Sm}或\p{Math_Symbol}：数学符号。</li>
<li>\p{Sc}或\p{Currency_Symbol}：通货符号。</li>
<li>\p{Sk}或\p{Modifier_Symbol}：组合为其他字符的符号。</li>
<li>\p{So}或\p{Other_Symbol}：其他符号。</li>
</ul>
</li>
<li>数值字符\p{N}<ul>
<li>\p{Nd}或\p{Decimal_Digit_Number}：所有文本中的数字0至9字符，不含形意符号。</li>
<li>\p{Nl}或\p{Letter_Number}：看起来像字母的符号，包含罗马数字。</li>
<li>\p{No}或\p{Other_Number}：上角标或下角标数字，或者其他不属于0至9的数字。不含形意符号。</li>
</ul>
</li>
<li>标点符号\p{P}<ul>
<li>\p{Pd}或\p{Dash_Punctuation}：任何种类的连字号或连接号。</li>
<li>\p{Ps}或\p{Open_Punctuation}：任何种类开括号。</li>
<li>\p{Pe}或\p{Close_Punctuation}：任何种类闭括号。</li>
<li>\p{Pi}或\p{Initial_Punctuation}：任何种类开引号。</li>
<li>\p{Pf}或\p{Final_Punctuation}：任何种类闭引号。</li>
<li>\p{Pc}或\p{Connector_Punctuation}：连接词的标点符号，如下划线。</li>
<li>\p{Po}或\p{Other_Punctuation}：其他标点符号。</li>
</ul>
</li>
<li>其它符号\p{C}(包括不可见控制字符与未用码位)<ul>
<li>\p{Cc}或\p{Control}：ASCII或Latin-1控制字符0x00-0x1F与0x7F-0x9F。</li>
<li>\p{Cf}或\p{Format}：不可见的格式化指示字符。</li>
<li>\p{Co}或\p{Private_Use}：私用码位。</li>
<li>\p{Cs}或\p{Surrogate}：UTF-16编码的代理对的一半。</li>
<li>\p{Cn}或\p{Unassigned}：未被使用的码位。</li>
</ul>
</li>
</ul>
</li>
<li><p>Unicode Block：按照编码区间划分Unicode字符，每个Unicode Block中的字符编码属于一个编码区间。例如Java语言\p{ InCJK_Compatibility_Ideographs }。</p>
</li>
<li><p>Unicode Script：按照字符所属的书写系统来划分Unicode字符。例如\p{Han}表示汉字(中文字符)。</p>
</li>
</ul>
<p>这三种Unicode性质对应的字符组补集是将开头的\p改为\P，其他不变。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="POSIX字符组"><a href="#POSIX字符组" class="headerlink" title="POSIX字符组"></a>POSIX字符组</h2><table>
<thead>
<tr>
<th align="center">POSIX字符组</th>
<th align="center">说明</th>
<th align="center">ASCII环境</th>
<th align="center">Unicode环境</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[:alnum:]</td>
<td align="center">字母字符和数字字符</td>
<td align="center">[a-zA-Z0-9]</td>
<td align="center">[\p{L&amp;}\p{Nd}]</td>
</tr>
<tr>
<td align="center">[:alpha:]</td>
<td align="center">字母</td>
<td align="center">[a-zA-Z]</td>
<td align="center">\p{L&amp;}</td>
</tr>
<tr>
<td align="center">[:ascii:]</td>
<td align="center">ASCII字符</td>
<td align="center">[\x00-\x7F]</td>
<td align="center">\p{InBasicLatin}</td>
</tr>
<tr>
<td align="center">[:blank:]</td>
<td align="center">空格字符和制表符</td>
<td align="center">[ \t]</td>
<td align="center">[\p{Zs}\t]</td>
</tr>
<tr>
<td align="center">[:cntrl:]</td>
<td align="center">控制字符</td>
<td align="center">[\x00-\x1F\x7F]</td>
<td align="center">\p{Cc}</td>
</tr>
<tr>
<td align="center">[:digit:]</td>
<td align="center">数字字符</td>
<td align="center">[0-9]</td>
<td align="center">\p{Nd}</td>
</tr>
<tr>
<td align="center">[:graph:]</td>
<td align="center">空白字符外的字符</td>
<td align="center">[\x21-\x7E]</td>
<td align="center">[^\p{Z}\p{C}]</td>
</tr>
<tr>
<td align="center">[:lower:]</td>
<td align="center">小写字母字符</td>
<td align="center">[a-z]</td>
<td align="center">\p{Ll}</td>
</tr>
<tr>
<td align="center">[:print:]</td>
<td align="center">类似[:graph:]但包含空白字符</td>
<td align="center">[\x20-\x7E]</td>
<td align="center">\P{C}</td>
</tr>
<tr>
<td align="center">[:punct:]</td>
<td align="center">标点符号</td>
<td align="center">[][!”#$%&amp;’()*+,.&#x2F;:;&lt;&#x3D;&gt;?@^_{|}~-]</td>
<td align="center">[\p{P}\p{S}]</td>
</tr>
<tr>
<td align="center">[:space:]</td>
<td align="center">空白字符</td>
<td align="center">[ \t\r\n\v\f]</td>
<td align="center">[\p{Z}\t\r\n\v\f]</td>
</tr>
<tr>
<td align="center">[:upper:]</td>
<td align="center">大写字母字符</td>
<td align="center">[A-Z]</td>
<td align="center">\p{Lu}</td>
</tr>
<tr>
<td align="center">[:word:]</td>
<td align="center">字母字符</td>
<td align="center">[A-Za-z0-9_]</td>
<td align="center">[\p{L}\p{N}\p{Pc}]</td>
</tr>
<tr>
<td align="center">[:xdigit:]</td>
<td align="center">十六进制字符</td>
<td align="center">[A-Fa-f0-9]</td>
<td align="center">[A-Fa-f0-9]</td>
</tr>
</tbody></table>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><table>
<thead>
<tr>
<th align="center">优先权</th>
<th align="center">符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">最高</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">高</td>
<td align="center">()   (?:)   (?&#x3D;)   []</td>
</tr>
<tr>
<td align="center">中</td>
<td align="center">*   +   ?   {n}   {n,}   {n,m}</td>
</tr>
<tr>
<td align="center">低</td>
<td align="center">^   $   中介字符</td>
</tr>
<tr>
<td align="center">更低</td>
<td align="center">串接</td>
</tr>
<tr>
<td align="center">最低</td>
<td align="center">|</td>
</tr>
</tbody></table>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://regexr.com/">RegExr: Learn, Build, &amp; Test RegEx</a></p>
<p><a href="https://www.gnu.org/software/sed/manual/html_node/BRE-vs-ERE.html">BRE vs ERE (sed, a stream editor) (gnu.org)</a></p>
<p><a href="https://www.pcre.org/">PCRE - Perl Compatible Regular Expressions</a></p>
<p><a href="https://docs.python.org/zh-cn/3/library/re.html">re — 正则表达式操作 — Python 3.9.5 文档</a></p>
]]></content>
      <categories>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/2021/10/03/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>shell是一个用户与Linux进行交互的接口程序，通常它会输出一个提示符，等待用户输入命令。如果该命令行的第一个的单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。Bash是当前Linux标准的默认shell。其他的shell包括zsh、powershell等。常用的Linux命令见附录。</p>
<span id="more"></span>

<h1 id="流、管道和重定向"><a href="#流、管道和重定向" class="headerlink" title="流、管道和重定向"></a>流、管道和重定向</h1><p>在操作系统中，流(stream)是一个很重要的概念，可以把它简单理解成一串连续的、可边读边处理的数据。其中标准流(standard stream)可以分为标准输入、标准输出和标准错误。</p>
<p>文件描述符(file descriptor)是内核为管理已打开的文件所创建的索引，使用一个非负整数来指代被打开的文件。Linux中的一切都可看作文件，流也不例外，所以输入和输出就被当做对应文件的读写来执行。标准流的定义在头文件unistd.h中，见附录。</p>
<p>管道(pipeline)是指一系列进程通过标准流连接在一起，前一个进程的输出(stdout)直接作为后一个进程的输入(stdin)。管道符号为”|”，例如：“ps -aux | grep bash”。常见Linux输入输出重定向见附录。</p>
<h1 id="根目录结构"><a href="#根目录结构" class="headerlink" title="根目录结构"></a>根目录结构</h1><p>Linux中的一切都可以看成文件，所有的文件和目录被组织成一个以根节点(斜杠&#x2F;)开始的倒置的树状结构，系统中的每个文件都是根目录的直接或间接后代。</p>
<p>Linux文件的三种基本文件类型分别如下：</p>
<ul>
<li>普通文件：包含文本文件(只含ASCII或Unicode字符，换行符为’\n’，即十六进制0x0A)和二进制文件(所有其他文件)。</li>
<li>目录：包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。</li>
<li>特殊文件：包括块文件、符号链接、管道、套接字等。</li>
</ul>
<p>目录层次结构中的位置用路径名来指定，分为绝对路径名(从根节点开始)和相对路径名(从当前目录开始)两种。使用tree命令可以直观地查看目录树。</p>
<h1 id="用户组及文件权限"><a href="#用户组及文件权限" class="headerlink" title="用户组及文件权限"></a>用户组及文件权限</h1><p>Linux是一个支持多用户的操作系统，每个用户都有User ID(UID)和Group ID(GID)，其中UID是对一个用户的单一身份标识，而GID则对应多个UID。可以使用id命令来查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lu0k@LU0K:~$ id root</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">lu0k@LU0K:~$ id lu0k</span><br><span class="line">uid=1000(lu0k) gid=1000(lu0k) groups=1000(lu0k)</span><br></pre></td></tr></table></figure>

<p>UID为0的用户具有系统的完全访问权。而UID为1000的普通用户对系统的访问权限有限。</p>
<p>GID的关系存储在&#x2F;etc&#x2F;group文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lu0k@LU0K:~$ cat /etc/group | head</span><br><span class="line">root:x:0:</span><br><span class="line">daemon:x:1:</span><br><span class="line">bin:x:2:</span><br><span class="line">sys:x:3:</span><br><span class="line">adm:x:4:syslog,lu0k</span><br><span class="line">tty:x:5:syslog</span><br></pre></td></tr></table></figure>

<p>所有用户的信息(除了密码)都保存再&#x2F;etc&#x2F;passwd文件中，加密过的用户密码则保存在&#x2F;etc&#x2F;shadow文件中，此文件的访问需要root权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lu0k@LU0K:~$ cat /etc/passwd | head</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br></pre></td></tr></table></figure>

<p>whoami命令用于打印当前有效的用户名称，shell中普通用户以’$’开头，root用户以’#’开头。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lu0k@LU0K:~$ whoami</span><br><span class="line">lu0k</span><br></pre></td></tr></table></figure>

<p>在里Linux中，文件或目录权限的控制分别以读取、写入和执行3种一般权限来区分，另有3种特殊权限可供使用。可以使用”ls -l [file]”来查看某文件或目录的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lu0k@LU0K:~$ ls -l .bashrc</span><br><span class="line">-rw-r--r-- 1 lu0k lu0k 3771 May 31 18:05 .bashrc</span><br></pre></td></tr></table></figure>

<ul>
<li>第一栏的第一个字母代表文件类型，目录(d)、普通文件(-)、链接文件(l)。</li>
<li>第一栏从第二个字母开始就是权限字符串，权限标志三个为一组，依次是所有者权限、组权限和其他人权限。权限对应关系见附录。</li>
</ul>
<p>用户可以使用chmod命令变更文件与目录的权限。权限范围被指定为所有者(u)、所属组(g)、其他人(o)和所有人(a)。chmod命令的用法如下：</p>
<ul>
<li>-R：递归处理，将目录下所有文件及子目录一并处理</li>
<li>&lt;权限范围&gt; + &lt;权限设置&gt;：添加权限。</li>
<li>&lt;权限范围&gt; - &lt;权限设置&gt;：删除权限。</li>
<li>&lt;权限范围&gt; &#x3D; &lt;权限设置&gt;：指定权限。</li>
</ul>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>环境变量相当于给系统或应用程序设置了一些参数，例如共享库的位置、命令行的参数等信息，对于程序的运行十分重要。环境变量字符串以”name &#x3D; value”这样的形式存在，大多数name由大写字母加下划线组成，通常把name部分称为环境变量名，value部分称为环境变量的值，其中value需要以’\0’结尾。</p>
<p>Linux环境变量的分类方法通常有下面两种：</p>
<ul>
<li>按生命周期划分：</li>
<li><ul>
<li>永久环境变量：修改相关配置文件，永久生效。</li>
<li>临时环境变量：通过export命令在当前终端下声明，关闭终端后失效。</li>
</ul>
</li>
<li>按作用域划分：</li>
<li><ul>
<li>系统环境变量：对该系统中的所有用户生效，可以在”&#x2F;etc&#x2F;profile”文件中声明。</li>
<li>用户环境变量：对特定用户生效，可以在”~&#x2F;.bashrc”文件中声明。</li>
</ul>
</li>
</ul>
<p>使用命令env可以打印出所有的环境变量，也可以对环境变量进行设置。</p>
<p><strong>PWN常用环境变量：</strong></p>
<ul>
<li>LD_PRELOAD：LD_PRELOAD环境变量可以定义程序运行时优先加载的动态链接库，这就允许预加载库中的函数和符号能够覆盖掉后加载的库中的函数和符号。可以通过修改该环境变量加载一个特定的libc。需要注意的是，ELF文件的INTERP字段指定了解释器ld.so的位置，如果该路径与动态链接库的位置不匹配，则会触发错误。</li>
<li>environ：libc中定义的全局变量environ指向内存中的环境变量表，更具体地，该表就位于栈上，因此通过泄露environ指针的地址，即可获得栈地址。</li>
</ul>
<h1 id="procfs文件系统"><a href="#procfs文件系统" class="headerlink" title="procfs文件系统"></a>procfs文件系统</h1><p>procfs文件系统是Linux内核提供的虚拟文件系统，为访问内核数据提供接口。它只占用内存而不占用存储。用户可以通过procfs查看有关系统硬件及当前正在运行的进程的信息，甚至可以通过修改其中的某些内容来改变内核的运行状态。</p>
<p>每个正在运行的进程都对应&#x2F;proc下的一个目录，目录名就是进程PID，每个目录包含：</p>
<ul>
<li>&#x2F;proc&#x2F;PID&#x2F;cmdline：启动该进程的命令行</li>
<li>&#x2F;proc&#x2F;PID&#x2F;cwd：当前工作目录的符号链接</li>
<li>&#x2F;proc&#x2F;PID&#x2F;environ：影响进程的环境变量的名字和值</li>
<li>&#x2F;proc&#x2F;PID&#x2F;exe：最初的可执行文件的符号链接, 如果它还存在的话</li>
<li>&#x2F;proc&#x2F;PID&#x2F;fd：一个目录，包含每个打开的文件描述符的符号链接</li>
<li>&#x2F;proc&#x2F;PID&#x2F;fdinfo：一个目录，包含每个打开的文件描述符的位置和标记</li>
<li>&#x2F;proc&#x2F;PID&#x2F;maps：一个文本文件，包含内存映射文件与块的信息</li>
<li>&#x2F;proc&#x2F;PID&#x2F;mem：一个二进制图像(image)表示进程的虚拟内存，只能通过ptrace化进程访问</li>
<li>&#x2F;proc&#x2F;PID&#x2F;root：该进程所能看到的根路径的符号链接。如果没有chroot监狱，那么进程的根路径是&#x2F;</li>
<li>&#x2F;proc&#x2F;PID&#x2F;status：包含了进程的基本信息，包括运行状态、内存使用</li>
<li>&#x2F;proc&#x2F;PID&#x2F;task：一个目录包含了硬链接到该进程启动的任何任务</li>
</ul>
<h1 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h1><p>计算机中采用了两种字节存储机制：大端(Big-endian)和小端(Little-endian)。其中大端规定MSB(Most Significan Bit&#x2F;Byte)在存储时放在低地址，在传输时放在流的开始；LSB(Least Significan Bit&#x2F;Byte)在存储时放在高地址，在传输时放在流的末尾。小端则正好相反。常见的Intel处理器使用小端，而PowerPC系列处理器使用大端，另外，TCP&#x2F;IP协议和Java虚拟机的字节序也是大端。</p>
<h1 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h1><p>函数调用约定是对函数调用时如何传递参数的一种约定。</p>
<ul>
<li>内核接口</li>
<li><ul>
<li>x86-32系统调用约定：Linux系统调用使用寄存器传递参数。eax为syscall_number，ebx、ecx、edx、esi和ebp用于将6个参数传递给系统调用。返回值保存在eax中。所有其他寄存器(包括EFLAGS)都保留在int 0x80中。</li>
<li>x86-64系统调用约定：内核接口使用的寄存器有rdi、rsi、rdx、r10、r8和r9。系统调用通过syscall指令完成。除了rcx、r11和rax，其他的寄存器都被保留。系统调用的编号必须在rax中传递。系统调用的参数限制为6个，不直接从堆栈上传递任何参数。返回时，rax中包含了系统调用的结果，而且只有INTEGER或者MEMORY类型的值才会被传递给内核。</li>
</ul>
</li>
<li>用户接口</li>
<li><ul>
<li>x86-32系统调用约定：参数通过栈传递。最后一个参数第一个被放进栈中，直到所有的参数都放置完毕，然后执行call指令。这也是Linux上C语言默认的方式。</li>
<li>x86-64系统调用约定：x86-64下通过寄存器传递参数，这样做会比通过栈具有更高的效率。它避免了内存中参数的存取和额外的指令。根据参数类型的不同，会使用寄存器或传参方式。如果参数的类型是MEMORY，则在栈上传递参数。如果类型是INTEGER，则顺序使用rdi、rsi、rdx、rcx、r8和r9。所以如果有多于6个的INTEGER参数，则后面的参数在栈上传递。</li>
</ul>
</li>
</ul>
<h1 id="核心转储"><a href="#核心转储" class="headerlink" title="核心转储"></a>核心转储</h1><p>当程序运行的过程中出现异常终止或崩溃，系统就会将程序崩溃时的内存、寄存器状态、堆栈指针、内存管理信息等记录下来，保存在一个文件中，叫作核心转储(Core Dump)。</p>
<p>会产生核心转储的信号有如下几种：</p>
<table>
<thead>
<tr>
<th align="center">信号</th>
<th align="center">动作</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIGQUIT</td>
<td align="center">Core</td>
<td align="center">通过键盘退出时</td>
</tr>
<tr>
<td align="center">SIGILL</td>
<td align="center">Core</td>
<td align="center">遇到不合法的指令时</td>
</tr>
<tr>
<td align="center">SIGABRT</td>
<td align="center">Core</td>
<td align="center">从abort中产生的信号</td>
</tr>
<tr>
<td align="center">SIGSEGV</td>
<td align="center">Core</td>
<td align="center">无效的内存访问</td>
</tr>
<tr>
<td align="center">SIGTRAP</td>
<td align="center">Core</td>
<td align="center">trace&#x2F;breakpoint陷阱</td>
</tr>
</tbody></table>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>在Linux中，系统调用是一些内核空间函数，是用户空间访问内核的唯一手段。这些函数与CPU架构有关，x86提供了358个系统调用，x86-64提供了322个系统调用。</p>
<p>在使用汇编写程序(如Shellcode)时，常常需要使用系统调用。早在2.6及更早版本的内核都使用软中断int 0x80进行系统调用，但是由于其性能较差，在后续版本的内核中被快速系统调用指令替代，32位系统使用sysenter(对应sysexit)指令，64位系统则使用syscall(对应sysret)指令。</p>
<p>一般情况下，应用程序通过在用户空间实现的应用编程接口(API)而不是系统调用来进行编程，而这些接口很多都是系统调用的封装。例如函数printf()的调用过程如下所示：</p>
<center>调用printf() ==> C库中的printf() ==> C库中的write() ==> write系统调用</center>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><table>
<thead>
<tr>
<th align="center">标准格式：命令名称  [命令参数]  [命令对象]</th>
<th align="center">命令功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ls  [OPTION]…  [FILE]…</td>
<td align="center">列出文件信息</td>
</tr>
<tr>
<td align="center">cd  [-L|[-P  [-e]]  [-@]]  [dir]</td>
<td align="center">切换工作目录</td>
</tr>
<tr>
<td align="center">pwd  [-LP]</td>
<td align="center">显示当前工作目录</td>
</tr>
<tr>
<td align="center">uname  [OPTION]</td>
<td align="center">打印系统信息</td>
</tr>
<tr>
<td align="center">whoami  [OPTION]</td>
<td align="center">打印用户名</td>
</tr>
<tr>
<td align="center">man  [OPTION…]  [SECTION]  PAGE…</td>
<td align="center">查询帮助信息</td>
</tr>
<tr>
<td align="center">find  [options]  [path…]  [expression]</td>
<td align="center">查找文件</td>
</tr>
<tr>
<td align="center">echo  [SHORT-OPTION]…  [STRING]…</td>
<td align="center">打印文本，参数’-e’可激活转义字符</td>
</tr>
<tr>
<td align="center">cat  [OPTION]…  [FILE]</td>
<td align="center">打印到标准输出</td>
</tr>
<tr>
<td align="center">less  [options]  file…</td>
<td align="center">分页打印文本，比more提供更丰富的功能</td>
</tr>
<tr>
<td align="center">head&#x2F;tail  [OPTION]…  [FILE]</td>
<td align="center">打印文本的前&#x2F;后N行</td>
</tr>
<tr>
<td align="center">grep  [OPTION]…  PATTERN  [FILE]…</td>
<td align="center">匹配文本模式</td>
</tr>
<tr>
<td align="center">cut  OPTION…  [FILE]…</td>
<td align="center">通过列提取文本</td>
</tr>
<tr>
<td align="center">diff  [OPTION]…  FILES</td>
<td align="center">比较文本差异</td>
</tr>
<tr>
<td align="center">mv  [OPTION]…  [-T]  SOURCE  DEST</td>
<td align="center">移动或重命名文件</td>
</tr>
<tr>
<td align="center">cp  [OPTION]…  [-T]  SOURCE  DEST</td>
<td align="center">复制文件</td>
</tr>
<tr>
<td align="center">rm  [OPTION]…  [FILE]…</td>
<td align="center">删除文件</td>
</tr>
<tr>
<td align="center">ps  [options]</td>
<td align="center">查看进程状态</td>
</tr>
<tr>
<td align="center">top  [options]</td>
<td align="center">实时查看系统运行情况</td>
</tr>
<tr>
<td align="center">kill  [options]  &lt;pid&gt;  […]</td>
<td align="center">杀死进程</td>
</tr>
<tr>
<td align="center">ifconfig  [-v]  [-a]  [-s]  [interface]</td>
<td align="center">查看或设置网络设备</td>
</tr>
<tr>
<td align="center">ping  [options]  destination</td>
<td align="center">判断网络主机是否响应</td>
</tr>
<tr>
<td align="center">netstat  [options]</td>
<td align="center">查看网络、路由器、接口等信息</td>
</tr>
<tr>
<td align="center">nc  [options]</td>
<td align="center">建立TCP&#x2F;UDP连接并监听</td>
</tr>
<tr>
<td align="center">su  [options]  [username]</td>
<td align="center">切换到用户</td>
</tr>
<tr>
<td align="center">touch  [OPTION]…  FILE…</td>
<td align="center">创建文件</td>
</tr>
<tr>
<td align="center">mkdir  [OPTION]…  DIRECTORY</td>
<td align="center">创建目录</td>
</tr>
<tr>
<td align="center">chmod  [OPTION]…  MODE[,MODE]…  FILE…</td>
<td align="center">变更文件或目录权限</td>
</tr>
<tr>
<td align="center">chown  [OPTION]…  [OWNER][:[GROUP]]  FILE…</td>
<td align="center">变更文件或目录所属者</td>
</tr>
<tr>
<td align="center">nano  &#x2F;  vim  &#x2F;  emacs</td>
<td align="center">终端文本编辑器</td>
</tr>
<tr>
<td align="center">history  [-c]  [-d  offset]  [n]</td>
<td align="center">查看”.bash_history”中的历史命令</td>
</tr>
<tr>
<td align="center">exit</td>
<td align="center">退出shell</td>
</tr>
</tbody></table>
<h2 id="标准流定义"><a href="#标准流定义" class="headerlink" title="标准流定义"></a>标准流定义</h2><table>
<thead>
<tr>
<th align="center">文件描述符</th>
<th align="center">常量</th>
<th align="center">用途</th>
<th align="center">stdio流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">STDIN_FILENO</td>
<td align="center">标准输入</td>
<td align="center">stdin</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">STDOUT_FILENO</td>
<td align="center">标准输出</td>
<td align="center">stdout</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">STDERR_FILENO</td>
<td align="center">标准错误</td>
<td align="center">stderr</td>
</tr>
</tbody></table>
<h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><table>
<thead>
<tr>
<th align="center">重定向符号</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cmd &gt; file</td>
<td align="center">将cmd的标准输出重定向并覆盖file</td>
</tr>
<tr>
<td align="center">cmd &gt;&gt; file</td>
<td align="center">将cmd的标准输出重定向并追加到file</td>
</tr>
<tr>
<td align="center">cmd &lt; file</td>
<td align="center">将file作为cmd的标准输入</td>
</tr>
<tr>
<td align="center">cmd &lt;&lt; tag</td>
<td align="center">从标准输入中读取，直到遇到tag为止</td>
</tr>
<tr>
<td align="center">cmd &lt; file1 &gt; file2</td>
<td align="center">将file1作为cmd的标准输入并将标准输出重定向到file2</td>
</tr>
<tr>
<td align="center">cmd 2 &gt; file</td>
<td align="center">将cmd的标准错误重定向并覆盖file</td>
</tr>
<tr>
<td align="center">cmd 2 &gt;&gt; file</td>
<td align="center">将cmd的标准错误重定向并追加到file</td>
</tr>
<tr>
<td align="center">2 &gt;&amp; 1</td>
<td align="center">将标准错误和标准输出合并</td>
</tr>
</tbody></table>
<h2 id="权限对应表"><a href="#权限对应表" class="headerlink" title="权限对应表"></a>权限对应表</h2><table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">所有</td>
<td align="center">者</td>
<td align="center">权限</td>
<td align="center">组</td>
<td align="center">权</td>
<td align="center">限</td>
<td align="center">其他</td>
<td align="center">人</td>
<td align="center">权限</td>
</tr>
<tr>
<td align="center">文件权限</td>
<td align="center">读</td>
<td align="center">写</td>
<td align="center">执行</td>
<td align="center">读</td>
<td align="center">写</td>
<td align="center">执行</td>
<td align="center">读</td>
<td align="center">写</td>
<td align="center">执行</td>
</tr>
<tr>
<td align="center">d&#x2F;l&#x2F;s&#x2F;p&#x2F;c&#x2F;b&#x2F;-</td>
<td align="center">r</td>
<td align="center">w</td>
<td align="center">x</td>
<td align="center">r</td>
<td align="center">w</td>
<td align="center">x</td>
<td align="center">r</td>
<td align="center">w</td>
<td align="center">x</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Basic</tag>
      </tags>
  </entry>
</search>
